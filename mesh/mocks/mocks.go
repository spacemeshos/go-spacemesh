// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=mocks -destination=./mocks/mocks.go -source=./interface.go
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	gomock "go.uber.org/mock/gomock"
)

// MockconservativeState is a mock of conservativeState interface.
type MockconservativeState struct {
	ctrl     *gomock.Controller
	recorder *MockconservativeStateMockRecorder
}

// MockconservativeStateMockRecorder is the mock recorder for MockconservativeState.
type MockconservativeStateMockRecorder struct {
	mock *MockconservativeState
}

// NewMockconservativeState creates a new mock instance.
func NewMockconservativeState(ctrl *gomock.Controller) *MockconservativeState {
	mock := &MockconservativeState{ctrl: ctrl}
	mock.recorder = &MockconservativeStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockconservativeState) EXPECT() *MockconservativeStateMockRecorder {
	return m.recorder
}

// LinkTXsWithBlock mocks base method.
func (m *MockconservativeState) LinkTXsWithBlock(arg0 types.LayerID, arg1 types.BlockID, arg2 []types.TransactionID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LinkTXsWithBlock", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// LinkTXsWithBlock indicates an expected call of LinkTXsWithBlock.
func (mr *MockconservativeStateMockRecorder) LinkTXsWithBlock(arg0, arg1, arg2 any) *MockconservativeStateLinkTXsWithBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LinkTXsWithBlock", reflect.TypeOf((*MockconservativeState)(nil).LinkTXsWithBlock), arg0, arg1, arg2)
	return &MockconservativeStateLinkTXsWithBlockCall{Call: call}
}

// MockconservativeStateLinkTXsWithBlockCall wrap *gomock.Call
type MockconservativeStateLinkTXsWithBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateLinkTXsWithBlockCall) Return(arg0 error) *MockconservativeStateLinkTXsWithBlockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateLinkTXsWithBlockCall) Do(f func(types.LayerID, types.BlockID, []types.TransactionID) error) *MockconservativeStateLinkTXsWithBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateLinkTXsWithBlockCall) DoAndReturn(f func(types.LayerID, types.BlockID, []types.TransactionID) error) *MockconservativeStateLinkTXsWithBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LinkTXsWithProposal mocks base method.
func (m *MockconservativeState) LinkTXsWithProposal(arg0 types.LayerID, arg1 types.ProposalID, arg2 []types.TransactionID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LinkTXsWithProposal", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// LinkTXsWithProposal indicates an expected call of LinkTXsWithProposal.
func (mr *MockconservativeStateMockRecorder) LinkTXsWithProposal(arg0, arg1, arg2 any) *MockconservativeStateLinkTXsWithProposalCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LinkTXsWithProposal", reflect.TypeOf((*MockconservativeState)(nil).LinkTXsWithProposal), arg0, arg1, arg2)
	return &MockconservativeStateLinkTXsWithProposalCall{Call: call}
}

// MockconservativeStateLinkTXsWithProposalCall wrap *gomock.Call
type MockconservativeStateLinkTXsWithProposalCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateLinkTXsWithProposalCall) Return(arg0 error) *MockconservativeStateLinkTXsWithProposalCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateLinkTXsWithProposalCall) Do(f func(types.LayerID, types.ProposalID, []types.TransactionID) error) *MockconservativeStateLinkTXsWithProposalCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateLinkTXsWithProposalCall) DoAndReturn(f func(types.LayerID, types.ProposalID, []types.TransactionID) error) *MockconservativeStateLinkTXsWithProposalCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertCache mocks base method.
func (m *MockconservativeState) RevertCache(arg0 types.LayerID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RevertCache", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// RevertCache indicates an expected call of RevertCache.
func (mr *MockconservativeStateMockRecorder) RevertCache(arg0 any) *MockconservativeStateRevertCacheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertCache", reflect.TypeOf((*MockconservativeState)(nil).RevertCache), arg0)
	return &MockconservativeStateRevertCacheCall{Call: call}
}

// MockconservativeStateRevertCacheCall wrap *gomock.Call
type MockconservativeStateRevertCacheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateRevertCacheCall) Return(arg0 error) *MockconservativeStateRevertCacheCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateRevertCacheCall) Do(f func(types.LayerID) error) *MockconservativeStateRevertCacheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateRevertCacheCall) DoAndReturn(f func(types.LayerID) error) *MockconservativeStateRevertCacheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateCache mocks base method.
func (m *MockconservativeState) UpdateCache(arg0 context.Context, arg1 types.LayerID, arg2 types.BlockID, arg3 []types.TransactionWithResult, arg4 []types.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateCache", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateCache indicates an expected call of UpdateCache.
func (mr *MockconservativeStateMockRecorder) UpdateCache(arg0, arg1, arg2, arg3, arg4 any) *MockconservativeStateUpdateCacheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateCache", reflect.TypeOf((*MockconservativeState)(nil).UpdateCache), arg0, arg1, arg2, arg3, arg4)
	return &MockconservativeStateUpdateCacheCall{Call: call}
}

// MockconservativeStateUpdateCacheCall wrap *gomock.Call
type MockconservativeStateUpdateCacheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateUpdateCacheCall) Return(arg0 error) *MockconservativeStateUpdateCacheCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateUpdateCacheCall) Do(f func(context.Context, types.LayerID, types.BlockID, []types.TransactionWithResult, []types.Transaction) error) *MockconservativeStateUpdateCacheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateUpdateCacheCall) DoAndReturn(f func(context.Context, types.LayerID, types.BlockID, []types.TransactionWithResult, []types.Transaction) error) *MockconservativeStateUpdateCacheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockVmState is a mock of VmState interface.
type MockVmState struct {
	ctrl     *gomock.Controller
	recorder *MockVmStateMockRecorder
}

// MockVmStateMockRecorder is the mock recorder for MockVmState.
type MockVmStateMockRecorder struct {
	mock *MockVmState
}

// NewMockVmState creates a new mock instance.
func NewMockVmState(ctrl *gomock.Controller) *MockVmState {
	mock := &MockVmState{ctrl: ctrl}
	mock.recorder = &MockVmStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVmState) EXPECT() *MockVmStateMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockVmState) Apply(arg0 types.LayerID, arg1 []types.Transaction, arg2 []types.CoinbaseReward) ([]types.Transaction, []types.TransactionWithResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", arg0, arg1, arg2)
	ret0, _ := ret[0].([]types.Transaction)
	ret1, _ := ret[1].([]types.TransactionWithResult)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Apply indicates an expected call of Apply.
func (mr *MockVmStateMockRecorder) Apply(arg0, arg1, arg2 any) *MockVmStateApplyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockVmState)(nil).Apply), arg0, arg1, arg2)
	return &MockVmStateApplyCall{Call: call}
}

// MockVmStateApplyCall wrap *gomock.Call
type MockVmStateApplyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockVmStateApplyCall) Return(arg0 []types.Transaction, arg1 []types.TransactionWithResult, arg2 error) *MockVmStateApplyCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockVmStateApplyCall) Do(f func(types.LayerID, []types.Transaction, []types.CoinbaseReward) ([]types.Transaction, []types.TransactionWithResult, error)) *MockVmStateApplyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockVmStateApplyCall) DoAndReturn(f func(types.LayerID, []types.Transaction, []types.CoinbaseReward) ([]types.Transaction, []types.TransactionWithResult, error)) *MockVmStateApplyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStateRoot mocks base method.
func (m *MockVmState) GetStateRoot() (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStateRoot")
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStateRoot indicates an expected call of GetStateRoot.
func (mr *MockVmStateMockRecorder) GetStateRoot() *MockVmStateGetStateRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStateRoot", reflect.TypeOf((*MockVmState)(nil).GetStateRoot))
	return &MockVmStateGetStateRootCall{Call: call}
}

// MockVmStateGetStateRootCall wrap *gomock.Call
type MockVmStateGetStateRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockVmStateGetStateRootCall) Return(arg0 types.Hash32, arg1 error) *MockVmStateGetStateRootCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockVmStateGetStateRootCall) Do(f func() (types.Hash32, error)) *MockVmStateGetStateRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockVmStateGetStateRootCall) DoAndReturn(f func() (types.Hash32, error)) *MockVmStateGetStateRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Revert mocks base method.
func (m *MockVmState) Revert(arg0 types.LayerID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Revert", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Revert indicates an expected call of Revert.
func (mr *MockVmStateMockRecorder) Revert(arg0 any) *MockVmStateRevertCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Revert", reflect.TypeOf((*MockVmState)(nil).Revert), arg0)
	return &MockVmStateRevertCall{Call: call}
}

// MockVmStateRevertCall wrap *gomock.Call
type MockVmStateRevertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockVmStateRevertCall) Return(arg0 error) *MockVmStateRevertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockVmStateRevertCall) Do(f func(types.LayerID) error) *MockVmStateRevertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockVmStateRevertCall) DoAndReturn(f func(types.LayerID) error) *MockVmStateRevertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocklayerClock is a mock of layerClock interface.
type MocklayerClock struct {
	ctrl     *gomock.Controller
	recorder *MocklayerClockMockRecorder
}

// MocklayerClockMockRecorder is the mock recorder for MocklayerClock.
type MocklayerClockMockRecorder struct {
	mock *MocklayerClock
}

// NewMocklayerClock creates a new mock instance.
func NewMocklayerClock(ctrl *gomock.Controller) *MocklayerClock {
	mock := &MocklayerClock{ctrl: ctrl}
	mock.recorder = &MocklayerClockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocklayerClock) EXPECT() *MocklayerClockMockRecorder {
	return m.recorder
}

// CurrentLayer mocks base method.
func (m *MocklayerClock) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MocklayerClockMockRecorder) CurrentLayer() *MocklayerClockCurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MocklayerClock)(nil).CurrentLayer))
	return &MocklayerClockCurrentLayerCall{Call: call}
}

// MocklayerClockCurrentLayerCall wrap *gomock.Call
type MocklayerClockCurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocklayerClockCurrentLayerCall) Return(arg0 types.LayerID) *MocklayerClockCurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocklayerClockCurrentLayerCall) Do(f func() types.LayerID) *MocklayerClockCurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocklayerClockCurrentLayerCall) DoAndReturn(f func() types.LayerID) *MocklayerClockCurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
