// Code generated by MockGen. DO NOT EDIT.
// Source: ./syncer.go
//
// Generated by this command:
//
//	mockgen -typed -package=mocks -destination=./mocks/mocks.go -source=./syncer.go
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	fetch "github.com/spacemeshos/go-spacemesh/fetch"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	system "github.com/spacemeshos/go-spacemesh/system"
	gomock "go.uber.org/mock/gomock"
)

// Mockfetcher is a mock of fetcher interface.
type Mockfetcher struct {
	ctrl     *gomock.Controller
	recorder *MockfetcherMockRecorder
	isgomock struct{}
}

// MockfetcherMockRecorder is the mock recorder for Mockfetcher.
type MockfetcherMockRecorder struct {
	mock *Mockfetcher
}

// NewMockfetcher creates a new mock instance.
func NewMockfetcher(ctrl *gomock.Controller) *Mockfetcher {
	mock := &Mockfetcher{ctrl: ctrl}
	mock.recorder = &MockfetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockfetcher) EXPECT() *MockfetcherMockRecorder {
	return m.recorder
}

// GetAtxs mocks base method.
func (m *Mockfetcher) GetAtxs(arg0 context.Context, arg1 []types.ATXID, arg2 ...system.GetAtxOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAtxs", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// GetAtxs indicates an expected call of GetAtxs.
func (mr *MockfetcherMockRecorder) GetAtxs(arg0, arg1 any, arg2 ...any) *MockfetcherGetAtxsCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAtxs", reflect.TypeOf((*Mockfetcher)(nil).GetAtxs), varargs...)
	return &MockfetcherGetAtxsCall{Call: call}
}

// MockfetcherGetAtxsCall wrap *gomock.Call
type MockfetcherGetAtxsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockfetcherGetAtxsCall) Return(arg0 error) *MockfetcherGetAtxsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockfetcherGetAtxsCall) Do(f func(context.Context, []types.ATXID, ...system.GetAtxOpt) error) *MockfetcherGetAtxsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockfetcherGetAtxsCall) DoAndReturn(f func(context.Context, []types.ATXID, ...system.GetAtxOpt) error) *MockfetcherGetAtxsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PeerEpochInfo mocks base method.
func (m *Mockfetcher) PeerEpochInfo(arg0 context.Context, arg1 p2p.Peer, arg2 types.EpochID) (*fetch.EpochData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeerEpochInfo", arg0, arg1, arg2)
	ret0, _ := ret[0].(*fetch.EpochData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PeerEpochInfo indicates an expected call of PeerEpochInfo.
func (mr *MockfetcherMockRecorder) PeerEpochInfo(arg0, arg1, arg2 any) *MockfetcherPeerEpochInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeerEpochInfo", reflect.TypeOf((*Mockfetcher)(nil).PeerEpochInfo), arg0, arg1, arg2)
	return &MockfetcherPeerEpochInfoCall{Call: call}
}

// MockfetcherPeerEpochInfoCall wrap *gomock.Call
type MockfetcherPeerEpochInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockfetcherPeerEpochInfoCall) Return(arg0 *fetch.EpochData, arg1 error) *MockfetcherPeerEpochInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockfetcherPeerEpochInfoCall) Do(f func(context.Context, p2p.Peer, types.EpochID) (*fetch.EpochData, error)) *MockfetcherPeerEpochInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockfetcherPeerEpochInfoCall) DoAndReturn(f func(context.Context, p2p.Peer, types.EpochID) (*fetch.EpochData, error)) *MockfetcherPeerEpochInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SelectBestShuffled mocks base method.
func (m *Mockfetcher) SelectBestShuffled(arg0 int) []p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SelectBestShuffled", arg0)
	ret0, _ := ret[0].([]p2p.Peer)
	return ret0
}

// SelectBestShuffled indicates an expected call of SelectBestShuffled.
func (mr *MockfetcherMockRecorder) SelectBestShuffled(arg0 any) *MockfetcherSelectBestShuffledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SelectBestShuffled", reflect.TypeOf((*Mockfetcher)(nil).SelectBestShuffled), arg0)
	return &MockfetcherSelectBestShuffledCall{Call: call}
}

// MockfetcherSelectBestShuffledCall wrap *gomock.Call
type MockfetcherSelectBestShuffledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockfetcherSelectBestShuffledCall) Return(arg0 []p2p.Peer) *MockfetcherSelectBestShuffledCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockfetcherSelectBestShuffledCall) Do(f func(int) []p2p.Peer) *MockfetcherSelectBestShuffledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockfetcherSelectBestShuffledCall) DoAndReturn(f func(int) []p2p.Peer) *MockfetcherSelectBestShuffledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
