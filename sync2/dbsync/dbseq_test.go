package dbsync

import (
	"context"
	"encoding/hex"
	"fmt"
	"slices"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/spacemeshos/go-spacemesh/sql"
	"github.com/spacemeshos/go-spacemesh/sync2/types"
)

func createDB(t *testing.T, keyLen int) sql.Database {
	db := sql.InMemoryTest(t)
	_, err := db.Exec(fmt.Sprintf("create table foo(id char(%d) not null primary key)", keyLen), nil, nil)
	require.NoError(t, err)
	return db
}

func insertDBItems(t *testing.T, db sql.Database, content []types.KeyBytes) {
	err := db.WithTx(context.Background(), func(tx sql.Transaction) error {
		for _, id := range content {
			_, err := tx.Exec(
				"insert into foo(id) values(?)",
				func(stmt *sql.Statement) {
					stmt.BindBytes(1, id)
				}, nil)
			if err != nil {
				return err
			}
		}
		return nil
	})
	require.NoError(t, err)
}

func deleteDBItems(t *testing.T, db sql.Database) {
	_, err := db.Exec("delete from foo", nil, nil)
	require.NoError(t, err)
}

func populateDB(t *testing.T, keyLen int, content []types.KeyBytes) sql.Database {
	db := createDB(t, keyLen)
	insertDBItems(t, db, content)
	return db
}

func TestDBRangeIterator(t *testing.T) {
	db := createDB(t, 4)
	for _, tc := range []struct {
		items []types.KeyBytes
		from  types.KeyBytes
		fromN int
	}{
		{
			items: nil,
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x00},
		},
		{
			items: nil,
			from:  types.KeyBytes{0x80, 0x00, 0x00, 0x00},
		},
		{
			items: nil,
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
		},
		{
			items: []types.KeyBytes{
				{0x00, 0x00, 0x00, 0x00},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0x00, 0x00, 0x00, 0x00},
			},
			from:  types.KeyBytes{0x01, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0x00, 0x00, 0x00, 0x00},
			},
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0x01, 0x02, 0x03, 0x04},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0x01, 0x02, 0x03, 0x04},
			},
			from:  types.KeyBytes{0x01, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0x01, 0x02, 0x03, 0x04},
			},
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0x01, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				{0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x00},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x01},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x02},
			fromN: 1,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x03},
			fromN: 1,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x05},
			fromN: 2,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x00, 0x07},
			fromN: 3,
		},
		{
			items: []types.KeyBytes{
				0: {0x00, 0x00, 0x00, 0x01},
				1: {0x00, 0x00, 0x00, 0x03},
				2: {0x00, 0x00, 0x00, 0x05},
				3: {0x00, 0x00, 0x00, 0x07},
			},
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
			fromN: 0,
		},
		{
			items: []types.KeyBytes{
				0:  {0x00, 0x00, 0x00, 0x01},
				1:  {0x00, 0x00, 0x00, 0x03},
				2:  {0x00, 0x00, 0x00, 0x05},
				3:  {0x00, 0x00, 0x00, 0x07},
				4:  {0x00, 0x00, 0x01, 0x00},
				5:  {0x00, 0x00, 0x03, 0x00},
				6:  {0x00, 0x01, 0x00, 0x00},
				7:  {0x00, 0x05, 0x00, 0x00},
				8:  {0x03, 0x05, 0x00, 0x00},
				9:  {0x09, 0x05, 0x00, 0x00},
				10: {0x0a, 0x05, 0x00, 0x00},
				11: {0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0x00, 0x00, 0x03, 0x01},
			fromN: 6,
		},
		{
			items: []types.KeyBytes{
				0:  {0x00, 0x00, 0x00, 0x01},
				1:  {0x00, 0x00, 0x00, 0x03},
				2:  {0x00, 0x00, 0x00, 0x05},
				3:  {0x00, 0x00, 0x00, 0x07},
				4:  {0x00, 0x00, 0x01, 0x00},
				5:  {0x00, 0x00, 0x03, 0x00},
				6:  {0x00, 0x01, 0x00, 0x00},
				7:  {0x00, 0x05, 0x00, 0x00},
				8:  {0x03, 0x05, 0x00, 0x00},
				9:  {0x09, 0x05, 0x00, 0x00},
				10: {0x0a, 0x05, 0x00, 0x00},
				11: {0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0x00, 0x01, 0x00, 0x00},
			fromN: 6,
		},
		{
			items: []types.KeyBytes{
				0:  {0x00, 0x00, 0x00, 0x01},
				1:  {0x00, 0x00, 0x00, 0x03},
				2:  {0x00, 0x00, 0x00, 0x05},
				3:  {0x00, 0x00, 0x00, 0x07},
				4:  {0x00, 0x00, 0x01, 0x00},
				5:  {0x00, 0x00, 0x03, 0x00},
				6:  {0x00, 0x01, 0x00, 0x00},
				7:  {0x00, 0x05, 0x00, 0x00},
				8:  {0x03, 0x05, 0x00, 0x00},
				9:  {0x09, 0x05, 0x00, 0x00},
				10: {0x0a, 0x05, 0x00, 0x00},
				11: {0xff, 0xff, 0xff, 0xff},
			},
			from:  types.KeyBytes{0xff, 0xff, 0xff, 0xff},
			fromN: 11,
		},
	} {
		deleteDBItems(t, db)
		insertDBItems(t, db, tc.items)
		cache := newLRU()
		st := &SyncedTable{
			TableName: "foo",
			IDColumn:  "id",
		}
		sts, err := st.snapshot(db)
		require.NoError(t, err)
		for maxChunkSize := 1; maxChunkSize < 12; maxChunkSize++ {
			seq := idsFromTable(db, sts, tc.from, -1, maxChunkSize, cache)
			// when there are no items, errEmptySet is returned
			for range 3 { // make sure the sequence is reusable
				var collected []types.KeyBytes
				var firstK types.KeyBytes
				for item, err := range seq {
					k := item.(types.KeyBytes)
					if firstK == nil {
						firstK = k
					} else if k.Compare(firstK) == 0 {
						break
					}
					collected = append(collected, k)
					require.NoError(t, err)
				}
				expected := slices.Concat(tc.items[tc.fromN:], tc.items[:tc.fromN])
				require.Equal(t, expected, collected, "count=%d from=%s maxChunkSize=%d",
					len(tc.items), hex.EncodeToString(tc.from), maxChunkSize)
			}
		}
	}
}
