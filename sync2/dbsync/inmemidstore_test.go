package dbsync

import (
	"context"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/spacemeshos/go-spacemesh/sync2/types"
)

func TestInMemIDStore(t *testing.T) {
	s := newInMemIDStore(32)
	ctx := context.Background()

	seq, err := s.all(ctx)
	require.NoError(t, err)
	for _ = range seq {
		require.Fail(t, "sequence not empty")
	}

	seq, err = s.from(ctx, types.HexToKeyBytes(
		"0000000000000000000000000000000000000000000000000000000000000000"))
	require.NoError(t, err)
	for _ = range seq {
		require.Fail(t, "sequence not empty")
	}

	for _, h := range []string{
		"0000000000000000000000000000000000000000000000000000000000000000",
		"1234561111111111111111111111111111111111111111111111111111111111",
		"123456789abcdef0000000000000000000000000000000000000000000000000",
		"5555555555555555555555555555555555555555555555555555555555555555",
		"8888888888888888888888888888888888888888888888888888888888888888",
		"8888889999999999999999999999999999999999999999999999999999999999",
		"abcdef1234567890000000000000000000000000000000000000000000000000",
	} {
		s.registerHash(types.HexToKeyBytes(h))
	}

	seq, err = s.all(ctx)
	require.NoError(t, err)
	for range 3 { // make sure seq is reusable
		var r []string
		n := 15
		for k, err := range seq {
			require.NoError(t, err)
			r = append(r, k.(types.KeyBytes).String())
			n--
			if n == 0 {
				break
			}
		}
		require.Equal(t, []string{
			"0000000000000000000000000000000000000000000000000000000000000000",
			"1234561111111111111111111111111111111111111111111111111111111111",
			"123456789abcdef0000000000000000000000000000000000000000000000000",
			"5555555555555555555555555555555555555555555555555555555555555555",
			"8888888888888888888888888888888888888888888888888888888888888888",
			"8888889999999999999999999999999999999999999999999999999999999999",
			"abcdef1234567890000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000000",
			"1234561111111111111111111111111111111111111111111111111111111111",
			"123456789abcdef0000000000000000000000000000000000000000000000000",
			"5555555555555555555555555555555555555555555555555555555555555555",
			"8888888888888888888888888888888888888888888888888888888888888888",
			"8888889999999999999999999999999999999999999999999999999999999999",
			"abcdef1234567890000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000000",
		}, r)
	}

	seq, err = s.from(ctx, types.HexToKeyBytes(
		"5555555555555555555555555555555555555555555555555555555555555555"))
	require.NoError(t, err)
	for range 3 { // make sure seq is reusable
		var r []string
		n := 15
		for k, err := range seq {
			require.NoError(t, err)
			r = append(r, k.(types.KeyBytes).String())
			n--
			if n == 0 {
				break
			}
		}
		require.Equal(t, []string{
			"5555555555555555555555555555555555555555555555555555555555555555",
			"8888888888888888888888888888888888888888888888888888888888888888",
			"8888889999999999999999999999999999999999999999999999999999999999",
			"abcdef1234567890000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000000",
			"1234561111111111111111111111111111111111111111111111111111111111",
			"123456789abcdef0000000000000000000000000000000000000000000000000",
			"5555555555555555555555555555555555555555555555555555555555555555",
			"8888888888888888888888888888888888888888888888888888888888888888",
			"8888889999999999999999999999999999999999999999999999999999999999",
			"abcdef1234567890000000000000000000000000000000000000000000000000",
			"0000000000000000000000000000000000000000000000000000000000000000",
			"1234561111111111111111111111111111111111111111111111111111111111",
			"123456789abcdef0000000000000000000000000000000000000000000000000",
			"5555555555555555555555555555555555555555555555555555555555555555",
		}, r)
	}
}
