// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=multipeer_test -destination=./mocks_test.go -source=./interface.go
//

// Package multipeer_test is a generated GoMock package.
package multipeer_test

import (
	context "context"
	io "io"
	reflect "reflect"
	time "time"

	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	multipeer "github.com/spacemeshos/go-spacemesh/sync2/multipeer"
	rangesync "github.com/spacemeshos/go-spacemesh/sync2/rangesync"
	gomock "go.uber.org/mock/gomock"
)

// MockOrderedSet is a mock of OrderedSet interface.
type MockOrderedSet struct {
	ctrl     *gomock.Controller
	recorder *MockOrderedSetMockRecorder
	isgomock struct{}
}

// MockOrderedSetMockRecorder is the mock recorder for MockOrderedSet.
type MockOrderedSetMockRecorder struct {
	mock *MockOrderedSet
}

// NewMockOrderedSet creates a new mock instance.
func NewMockOrderedSet(ctrl *gomock.Controller) *MockOrderedSet {
	mock := &MockOrderedSet{ctrl: ctrl}
	mock.recorder = &MockOrderedSetMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderedSet) EXPECT() *MockOrderedSetMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockOrderedSet) Add(k rangesync.KeyBytes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", k)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockOrderedSetMockRecorder) Add(k any) *MockOrderedSetAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockOrderedSet)(nil).Add), k)
	return &MockOrderedSetAddCall{Call: call}
}

// MockOrderedSetAddCall wrap *gomock.Call
type MockOrderedSetAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetAddCall) Return(arg0 error) *MockOrderedSetAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetAddCall) Do(f func(rangesync.KeyBytes) error) *MockOrderedSetAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetAddCall) DoAndReturn(f func(rangesync.KeyBytes) error) *MockOrderedSetAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Advance mocks base method.
func (m *MockOrderedSet) Advance() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Advance")
	ret0, _ := ret[0].(error)
	return ret0
}

// Advance indicates an expected call of Advance.
func (mr *MockOrderedSetMockRecorder) Advance() *MockOrderedSetAdvanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Advance", reflect.TypeOf((*MockOrderedSet)(nil).Advance))
	return &MockOrderedSetAdvanceCall{Call: call}
}

// MockOrderedSetAdvanceCall wrap *gomock.Call
type MockOrderedSetAdvanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetAdvanceCall) Return(arg0 error) *MockOrderedSetAdvanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetAdvanceCall) Do(f func() error) *MockOrderedSetAdvanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetAdvanceCall) DoAndReturn(f func() error) *MockOrderedSetAdvanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Copy mocks base method.
func (m *MockOrderedSet) Copy(syncScope bool) rangesync.OrderedSet {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", syncScope)
	ret0, _ := ret[0].(rangesync.OrderedSet)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockOrderedSetMockRecorder) Copy(syncScope any) *MockOrderedSetCopyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*MockOrderedSet)(nil).Copy), syncScope)
	return &MockOrderedSetCopyCall{Call: call}
}

// MockOrderedSetCopyCall wrap *gomock.Call
type MockOrderedSetCopyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetCopyCall) Return(arg0 rangesync.OrderedSet) *MockOrderedSetCopyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetCopyCall) Do(f func(bool) rangesync.OrderedSet) *MockOrderedSetCopyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetCopyCall) DoAndReturn(f func(bool) rangesync.OrderedSet) *MockOrderedSetCopyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Empty mocks base method.
func (m *MockOrderedSet) Empty() (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty")
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Empty indicates an expected call of Empty.
func (mr *MockOrderedSetMockRecorder) Empty() *MockOrderedSetEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockOrderedSet)(nil).Empty))
	return &MockOrderedSetEmptyCall{Call: call}
}

// MockOrderedSetEmptyCall wrap *gomock.Call
type MockOrderedSetEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetEmptyCall) Return(arg0 bool, arg1 error) *MockOrderedSetEmptyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetEmptyCall) Do(f func() (bool, error)) *MockOrderedSetEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetEmptyCall) DoAndReturn(f func() (bool, error)) *MockOrderedSetEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EnsureLoaded mocks base method.
func (m *MockOrderedSet) EnsureLoaded() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnsureLoaded")
	ret0, _ := ret[0].(error)
	return ret0
}

// EnsureLoaded indicates an expected call of EnsureLoaded.
func (mr *MockOrderedSetMockRecorder) EnsureLoaded() *MockOrderedSetEnsureLoadedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnsureLoaded", reflect.TypeOf((*MockOrderedSet)(nil).EnsureLoaded))
	return &MockOrderedSetEnsureLoadedCall{Call: call}
}

// MockOrderedSetEnsureLoadedCall wrap *gomock.Call
type MockOrderedSetEnsureLoadedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetEnsureLoadedCall) Return(arg0 error) *MockOrderedSetEnsureLoadedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetEnsureLoadedCall) Do(f func() error) *MockOrderedSetEnsureLoadedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetEnsureLoadedCall) DoAndReturn(f func() error) *MockOrderedSetEnsureLoadedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRangeInfo mocks base method.
func (m *MockOrderedSet) GetRangeInfo(x, y rangesync.KeyBytes) (rangesync.RangeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRangeInfo", x, y)
	ret0, _ := ret[0].(rangesync.RangeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRangeInfo indicates an expected call of GetRangeInfo.
func (mr *MockOrderedSetMockRecorder) GetRangeInfo(x, y any) *MockOrderedSetGetRangeInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRangeInfo", reflect.TypeOf((*MockOrderedSet)(nil).GetRangeInfo), x, y)
	return &MockOrderedSetGetRangeInfoCall{Call: call}
}

// MockOrderedSetGetRangeInfoCall wrap *gomock.Call
type MockOrderedSetGetRangeInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetGetRangeInfoCall) Return(arg0 rangesync.RangeInfo, arg1 error) *MockOrderedSetGetRangeInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetGetRangeInfoCall) Do(f func(rangesync.KeyBytes, rangesync.KeyBytes) (rangesync.RangeInfo, error)) *MockOrderedSetGetRangeInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetGetRangeInfoCall) DoAndReturn(f func(rangesync.KeyBytes, rangesync.KeyBytes) (rangesync.RangeInfo, error)) *MockOrderedSetGetRangeInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Has mocks base method.
func (m *MockOrderedSet) Has(arg0 rangesync.KeyBytes) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Has indicates an expected call of Has.
func (mr *MockOrderedSetMockRecorder) Has(arg0 any) *MockOrderedSetHasCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockOrderedSet)(nil).Has), arg0)
	return &MockOrderedSetHasCall{Call: call}
}

// MockOrderedSetHasCall wrap *gomock.Call
type MockOrderedSetHasCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetHasCall) Return(arg0 bool, arg1 error) *MockOrderedSetHasCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetHasCall) Do(f func(rangesync.KeyBytes) (bool, error)) *MockOrderedSetHasCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetHasCall) DoAndReturn(f func(rangesync.KeyBytes) (bool, error)) *MockOrderedSetHasCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Items mocks base method.
func (m *MockOrderedSet) Items() rangesync.SeqResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Items")
	ret0, _ := ret[0].(rangesync.SeqResult)
	return ret0
}

// Items indicates an expected call of Items.
func (mr *MockOrderedSetMockRecorder) Items() *MockOrderedSetItemsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Items", reflect.TypeOf((*MockOrderedSet)(nil).Items))
	return &MockOrderedSetItemsCall{Call: call}
}

// MockOrderedSetItemsCall wrap *gomock.Call
type MockOrderedSetItemsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetItemsCall) Return(arg0 rangesync.SeqResult) *MockOrderedSetItemsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetItemsCall) Do(f func() rangesync.SeqResult) *MockOrderedSetItemsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetItemsCall) DoAndReturn(f func() rangesync.SeqResult) *MockOrderedSetItemsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Receive mocks base method.
func (m *MockOrderedSet) Receive(k rangesync.KeyBytes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive", k)
	ret0, _ := ret[0].(error)
	return ret0
}

// Receive indicates an expected call of Receive.
func (mr *MockOrderedSetMockRecorder) Receive(k any) *MockOrderedSetReceiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockOrderedSet)(nil).Receive), k)
	return &MockOrderedSetReceiveCall{Call: call}
}

// MockOrderedSetReceiveCall wrap *gomock.Call
type MockOrderedSetReceiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetReceiveCall) Return(arg0 error) *MockOrderedSetReceiveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetReceiveCall) Do(f func(rangesync.KeyBytes) error) *MockOrderedSetReceiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetReceiveCall) DoAndReturn(f func(rangesync.KeyBytes) error) *MockOrderedSetReceiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Received mocks base method.
func (m *MockOrderedSet) Received() rangesync.SeqResult {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Received")
	ret0, _ := ret[0].(rangesync.SeqResult)
	return ret0
}

// Received indicates an expected call of Received.
func (mr *MockOrderedSetMockRecorder) Received() *MockOrderedSetReceivedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Received", reflect.TypeOf((*MockOrderedSet)(nil).Received))
	return &MockOrderedSetReceivedCall{Call: call}
}

// MockOrderedSetReceivedCall wrap *gomock.Call
type MockOrderedSetReceivedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetReceivedCall) Return(arg0 rangesync.SeqResult) *MockOrderedSetReceivedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetReceivedCall) Do(f func() rangesync.SeqResult) *MockOrderedSetReceivedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetReceivedCall) DoAndReturn(f func() rangesync.SeqResult) *MockOrderedSetReceivedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Recent mocks base method.
func (m *MockOrderedSet) Recent(since time.Time) (rangesync.SeqResult, int) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recent", since)
	ret0, _ := ret[0].(rangesync.SeqResult)
	ret1, _ := ret[1].(int)
	return ret0, ret1
}

// Recent indicates an expected call of Recent.
func (mr *MockOrderedSetMockRecorder) Recent(since any) *MockOrderedSetRecentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recent", reflect.TypeOf((*MockOrderedSet)(nil).Recent), since)
	return &MockOrderedSetRecentCall{Call: call}
}

// MockOrderedSetRecentCall wrap *gomock.Call
type MockOrderedSetRecentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetRecentCall) Return(arg0 rangesync.SeqResult, arg1 int) *MockOrderedSetRecentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetRecentCall) Do(f func(time.Time) (rangesync.SeqResult, int)) *MockOrderedSetRecentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetRecentCall) DoAndReturn(f func(time.Time) (rangesync.SeqResult, int)) *MockOrderedSetRecentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Release mocks base method.
func (m *MockOrderedSet) Release() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release")
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockOrderedSetMockRecorder) Release() *MockOrderedSetReleaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockOrderedSet)(nil).Release))
	return &MockOrderedSetReleaseCall{Call: call}
}

// MockOrderedSetReleaseCall wrap *gomock.Call
type MockOrderedSetReleaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetReleaseCall) Return(arg0 error) *MockOrderedSetReleaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetReleaseCall) Do(f func() error) *MockOrderedSetReleaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetReleaseCall) DoAndReturn(f func() error) *MockOrderedSetReleaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SplitRange mocks base method.
func (m *MockOrderedSet) SplitRange(x, y rangesync.KeyBytes, count int) (rangesync.SplitInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SplitRange", x, y, count)
	ret0, _ := ret[0].(rangesync.SplitInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SplitRange indicates an expected call of SplitRange.
func (mr *MockOrderedSetMockRecorder) SplitRange(x, y, count any) *MockOrderedSetSplitRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SplitRange", reflect.TypeOf((*MockOrderedSet)(nil).SplitRange), x, y, count)
	return &MockOrderedSetSplitRangeCall{Call: call}
}

// MockOrderedSetSplitRangeCall wrap *gomock.Call
type MockOrderedSetSplitRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockOrderedSetSplitRangeCall) Return(arg0 rangesync.SplitInfo, arg1 error) *MockOrderedSetSplitRangeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockOrderedSetSplitRangeCall) Do(f func(rangesync.KeyBytes, rangesync.KeyBytes, int) (rangesync.SplitInfo, error)) *MockOrderedSetSplitRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockOrderedSetSplitRangeCall) DoAndReturn(f func(rangesync.KeyBytes, rangesync.KeyBytes, int) (rangesync.SplitInfo, error)) *MockOrderedSetSplitRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockSyncBase is a mock of SyncBase interface.
type MockSyncBase struct {
	ctrl     *gomock.Controller
	recorder *MockSyncBaseMockRecorder
	isgomock struct{}
}

// MockSyncBaseMockRecorder is the mock recorder for MockSyncBase.
type MockSyncBaseMockRecorder struct {
	mock *MockSyncBase
}

// NewMockSyncBase creates a new mock instance.
func NewMockSyncBase(ctrl *gomock.Controller) *MockSyncBase {
	mock := &MockSyncBase{ctrl: ctrl}
	mock.recorder = &MockSyncBaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSyncBase) EXPECT() *MockSyncBaseMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockSyncBase) Count() (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockSyncBaseMockRecorder) Count() *MockSyncBaseCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockSyncBase)(nil).Count))
	return &MockSyncBaseCountCall{Call: call}
}

// MockSyncBaseCountCall wrap *gomock.Call
type MockSyncBaseCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncBaseCountCall) Return(arg0 int, arg1 error) *MockSyncBaseCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncBaseCountCall) Do(f func() (int, error)) *MockSyncBaseCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncBaseCountCall) DoAndReturn(f func() (int, error)) *MockSyncBaseCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Derive mocks base method.
func (m *MockSyncBase) Derive(p p2p.Peer) multipeer.Syncer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Derive", p)
	ret0, _ := ret[0].(multipeer.Syncer)
	return ret0
}

// Derive indicates an expected call of Derive.
func (mr *MockSyncBaseMockRecorder) Derive(p any) *MockSyncBaseDeriveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Derive", reflect.TypeOf((*MockSyncBase)(nil).Derive), p)
	return &MockSyncBaseDeriveCall{Call: call}
}

// MockSyncBaseDeriveCall wrap *gomock.Call
type MockSyncBaseDeriveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncBaseDeriveCall) Return(arg0 multipeer.Syncer) *MockSyncBaseDeriveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncBaseDeriveCall) Do(f func(p2p.Peer) multipeer.Syncer) *MockSyncBaseDeriveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncBaseDeriveCall) DoAndReturn(f func(p2p.Peer) multipeer.Syncer) *MockSyncBaseDeriveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Probe mocks base method.
func (m *MockSyncBase) Probe(ctx context.Context, p p2p.Peer) (rangesync.ProbeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Probe", ctx, p)
	ret0, _ := ret[0].(rangesync.ProbeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Probe indicates an expected call of Probe.
func (mr *MockSyncBaseMockRecorder) Probe(ctx, p any) *MockSyncBaseProbeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Probe", reflect.TypeOf((*MockSyncBase)(nil).Probe), ctx, p)
	return &MockSyncBaseProbeCall{Call: call}
}

// MockSyncBaseProbeCall wrap *gomock.Call
type MockSyncBaseProbeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncBaseProbeCall) Return(arg0 rangesync.ProbeResult, arg1 error) *MockSyncBaseProbeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncBaseProbeCall) Do(f func(context.Context, p2p.Peer) (rangesync.ProbeResult, error)) *MockSyncBaseProbeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncBaseProbeCall) DoAndReturn(f func(context.Context, p2p.Peer) (rangesync.ProbeResult, error)) *MockSyncBaseProbeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Wait mocks base method.
func (m *MockSyncBase) Wait() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Wait")
	ret0, _ := ret[0].(error)
	return ret0
}

// Wait indicates an expected call of Wait.
func (mr *MockSyncBaseMockRecorder) Wait() *MockSyncBaseWaitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Wait", reflect.TypeOf((*MockSyncBase)(nil).Wait))
	return &MockSyncBaseWaitCall{Call: call}
}

// MockSyncBaseWaitCall wrap *gomock.Call
type MockSyncBaseWaitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncBaseWaitCall) Return(arg0 error) *MockSyncBaseWaitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncBaseWaitCall) Do(f func() error) *MockSyncBaseWaitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncBaseWaitCall) DoAndReturn(f func() error) *MockSyncBaseWaitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockSyncer is a mock of Syncer interface.
type MockSyncer struct {
	ctrl     *gomock.Controller
	recorder *MockSyncerMockRecorder
	isgomock struct{}
}

// MockSyncerMockRecorder is the mock recorder for MockSyncer.
type MockSyncerMockRecorder struct {
	mock *MockSyncer
}

// NewMockSyncer creates a new mock instance.
func NewMockSyncer(ctrl *gomock.Controller) *MockSyncer {
	mock := &MockSyncer{ctrl: ctrl}
	mock.recorder = &MockSyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSyncer) EXPECT() *MockSyncerMockRecorder {
	return m.recorder
}

// Peer mocks base method.
func (m *MockSyncer) Peer() p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peer")
	ret0, _ := ret[0].(p2p.Peer)
	return ret0
}

// Peer indicates an expected call of Peer.
func (mr *MockSyncerMockRecorder) Peer() *MockSyncerPeerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peer", reflect.TypeOf((*MockSyncer)(nil).Peer))
	return &MockSyncerPeerCall{Call: call}
}

// MockSyncerPeerCall wrap *gomock.Call
type MockSyncerPeerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncerPeerCall) Return(arg0 p2p.Peer) *MockSyncerPeerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncerPeerCall) Do(f func() p2p.Peer) *MockSyncerPeerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncerPeerCall) DoAndReturn(f func() p2p.Peer) *MockSyncerPeerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Release mocks base method.
func (m *MockSyncer) Release() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release")
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockSyncerMockRecorder) Release() *MockSyncerReleaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockSyncer)(nil).Release))
	return &MockSyncerReleaseCall{Call: call}
}

// MockSyncerReleaseCall wrap *gomock.Call
type MockSyncerReleaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncerReleaseCall) Return(arg0 error) *MockSyncerReleaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncerReleaseCall) Do(f func() error) *MockSyncerReleaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncerReleaseCall) DoAndReturn(f func() error) *MockSyncerReleaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Serve mocks base method.
func (m *MockSyncer) Serve(ctx context.Context, stream io.ReadWriter) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Serve", ctx, stream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Serve indicates an expected call of Serve.
func (mr *MockSyncerMockRecorder) Serve(ctx, stream any) *MockSyncerServeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Serve", reflect.TypeOf((*MockSyncer)(nil).Serve), ctx, stream)
	return &MockSyncerServeCall{Call: call}
}

// MockSyncerServeCall wrap *gomock.Call
type MockSyncerServeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncerServeCall) Return(arg0 error) *MockSyncerServeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncerServeCall) Do(f func(context.Context, io.ReadWriter) error) *MockSyncerServeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncerServeCall) DoAndReturn(f func(context.Context, io.ReadWriter) error) *MockSyncerServeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sync mocks base method.
func (m *MockSyncer) Sync(ctx context.Context, x, y rangesync.KeyBytes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sync", ctx, x, y)
	ret0, _ := ret[0].(error)
	return ret0
}

// Sync indicates an expected call of Sync.
func (mr *MockSyncerMockRecorder) Sync(ctx, x, y any) *MockSyncerSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockSyncer)(nil).Sync), ctx, x, y)
	return &MockSyncerSyncCall{Call: call}
}

// MockSyncerSyncCall wrap *gomock.Call
type MockSyncerSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncerSyncCall) Return(arg0 error) *MockSyncerSyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncerSyncCall) Do(f func(context.Context, rangesync.KeyBytes, rangesync.KeyBytes) error) *MockSyncerSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncerSyncCall) DoAndReturn(f func(context.Context, rangesync.KeyBytes, rangesync.KeyBytes) error) *MockSyncerSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockSyncKeyHandler is a mock of SyncKeyHandler interface.
type MockSyncKeyHandler struct {
	ctrl     *gomock.Controller
	recorder *MockSyncKeyHandlerMockRecorder
	isgomock struct{}
}

// MockSyncKeyHandlerMockRecorder is the mock recorder for MockSyncKeyHandler.
type MockSyncKeyHandlerMockRecorder struct {
	mock *MockSyncKeyHandler
}

// NewMockSyncKeyHandler creates a new mock instance.
func NewMockSyncKeyHandler(ctrl *gomock.Controller) *MockSyncKeyHandler {
	mock := &MockSyncKeyHandler{ctrl: ctrl}
	mock.recorder = &MockSyncKeyHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSyncKeyHandler) EXPECT() *MockSyncKeyHandlerMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockSyncKeyHandler) Commit(peer p2p.Peer, base, new multipeer.OrderedSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", peer, base, new)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockSyncKeyHandlerMockRecorder) Commit(peer, base, new any) *MockSyncKeyHandlerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockSyncKeyHandler)(nil).Commit), peer, base, new)
	return &MockSyncKeyHandlerCommitCall{Call: call}
}

// MockSyncKeyHandlerCommitCall wrap *gomock.Call
type MockSyncKeyHandlerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncKeyHandlerCommitCall) Return(arg0 error) *MockSyncKeyHandlerCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncKeyHandlerCommitCall) Do(f func(p2p.Peer, multipeer.OrderedSet, multipeer.OrderedSet) error) *MockSyncKeyHandlerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncKeyHandlerCommitCall) DoAndReturn(f func(p2p.Peer, multipeer.OrderedSet, multipeer.OrderedSet) error) *MockSyncKeyHandlerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Receive mocks base method.
func (m *MockSyncKeyHandler) Receive(k rangesync.KeyBytes, peer p2p.Peer) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive", k, peer)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Receive indicates an expected call of Receive.
func (mr *MockSyncKeyHandlerMockRecorder) Receive(k, peer any) *MockSyncKeyHandlerReceiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockSyncKeyHandler)(nil).Receive), k, peer)
	return &MockSyncKeyHandlerReceiveCall{Call: call}
}

// MockSyncKeyHandlerReceiveCall wrap *gomock.Call
type MockSyncKeyHandlerReceiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockSyncKeyHandlerReceiveCall) Return(arg0 bool, arg1 error) *MockSyncKeyHandlerReceiveCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockSyncKeyHandlerReceiveCall) Do(f func(rangesync.KeyBytes, p2p.Peer) (bool, error)) *MockSyncKeyHandlerReceiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockSyncKeyHandlerReceiveCall) DoAndReturn(f func(rangesync.KeyBytes, p2p.Peer) (bool, error)) *MockSyncKeyHandlerReceiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPairwiseSyncer is a mock of PairwiseSyncer interface.
type MockPairwiseSyncer struct {
	ctrl     *gomock.Controller
	recorder *MockPairwiseSyncerMockRecorder
	isgomock struct{}
}

// MockPairwiseSyncerMockRecorder is the mock recorder for MockPairwiseSyncer.
type MockPairwiseSyncerMockRecorder struct {
	mock *MockPairwiseSyncer
}

// NewMockPairwiseSyncer creates a new mock instance.
func NewMockPairwiseSyncer(ctrl *gomock.Controller) *MockPairwiseSyncer {
	mock := &MockPairwiseSyncer{ctrl: ctrl}
	mock.recorder = &MockPairwiseSyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPairwiseSyncer) EXPECT() *MockPairwiseSyncerMockRecorder {
	return m.recorder
}

// Probe mocks base method.
func (m *MockPairwiseSyncer) Probe(ctx context.Context, peer p2p.Peer, os rangesync.OrderedSet, x, y rangesync.KeyBytes) (rangesync.ProbeResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Probe", ctx, peer, os, x, y)
	ret0, _ := ret[0].(rangesync.ProbeResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Probe indicates an expected call of Probe.
func (mr *MockPairwiseSyncerMockRecorder) Probe(ctx, peer, os, x, y any) *MockPairwiseSyncerProbeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Probe", reflect.TypeOf((*MockPairwiseSyncer)(nil).Probe), ctx, peer, os, x, y)
	return &MockPairwiseSyncerProbeCall{Call: call}
}

// MockPairwiseSyncerProbeCall wrap *gomock.Call
type MockPairwiseSyncerProbeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPairwiseSyncerProbeCall) Return(arg0 rangesync.ProbeResult, arg1 error) *MockPairwiseSyncerProbeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPairwiseSyncerProbeCall) Do(f func(context.Context, p2p.Peer, rangesync.OrderedSet, rangesync.KeyBytes, rangesync.KeyBytes) (rangesync.ProbeResult, error)) *MockPairwiseSyncerProbeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPairwiseSyncerProbeCall) DoAndReturn(f func(context.Context, p2p.Peer, rangesync.OrderedSet, rangesync.KeyBytes, rangesync.KeyBytes) (rangesync.ProbeResult, error)) *MockPairwiseSyncerProbeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Serve mocks base method.
func (m *MockPairwiseSyncer) Serve(context context.Context, stream io.ReadWriter, os rangesync.OrderedSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Serve", context, stream, os)
	ret0, _ := ret[0].(error)
	return ret0
}

// Serve indicates an expected call of Serve.
func (mr *MockPairwiseSyncerMockRecorder) Serve(context, stream, os any) *MockPairwiseSyncerServeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Serve", reflect.TypeOf((*MockPairwiseSyncer)(nil).Serve), context, stream, os)
	return &MockPairwiseSyncerServeCall{Call: call}
}

// MockPairwiseSyncerServeCall wrap *gomock.Call
type MockPairwiseSyncerServeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPairwiseSyncerServeCall) Return(arg0 error) *MockPairwiseSyncerServeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPairwiseSyncerServeCall) Do(f func(context.Context, io.ReadWriter, rangesync.OrderedSet) error) *MockPairwiseSyncerServeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPairwiseSyncerServeCall) DoAndReturn(f func(context.Context, io.ReadWriter, rangesync.OrderedSet) error) *MockPairwiseSyncerServeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sync mocks base method.
func (m *MockPairwiseSyncer) Sync(ctx context.Context, peer p2p.Peer, os rangesync.OrderedSet, x, y rangesync.KeyBytes) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sync", ctx, peer, os, x, y)
	ret0, _ := ret[0].(error)
	return ret0
}

// Sync indicates an expected call of Sync.
func (mr *MockPairwiseSyncerMockRecorder) Sync(ctx, peer, os, x, y any) *MockPairwiseSyncerSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sync", reflect.TypeOf((*MockPairwiseSyncer)(nil).Sync), ctx, peer, os, x, y)
	return &MockPairwiseSyncerSyncCall{Call: call}
}

// MockPairwiseSyncerSyncCall wrap *gomock.Call
type MockPairwiseSyncerSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPairwiseSyncerSyncCall) Return(arg0 error) *MockPairwiseSyncerSyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPairwiseSyncerSyncCall) Do(f func(context.Context, p2p.Peer, rangesync.OrderedSet, rangesync.KeyBytes, rangesync.KeyBytes) error) *MockPairwiseSyncerSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPairwiseSyncerSyncCall) DoAndReturn(f func(context.Context, p2p.Peer, rangesync.OrderedSet, rangesync.KeyBytes, rangesync.KeyBytes) error) *MockPairwiseSyncerSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocksyncRunner is a mock of syncRunner interface.
type MocksyncRunner struct {
	ctrl     *gomock.Controller
	recorder *MocksyncRunnerMockRecorder
	isgomock struct{}
}

// MocksyncRunnerMockRecorder is the mock recorder for MocksyncRunner.
type MocksyncRunnerMockRecorder struct {
	mock *MocksyncRunner
}

// NewMocksyncRunner creates a new mock instance.
func NewMocksyncRunner(ctrl *gomock.Controller) *MocksyncRunner {
	mock := &MocksyncRunner{ctrl: ctrl}
	mock.recorder = &MocksyncRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksyncRunner) EXPECT() *MocksyncRunnerMockRecorder {
	return m.recorder
}

// FullSync mocks base method.
func (m *MocksyncRunner) FullSync(ctx context.Context, syncPeers []p2p.Peer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FullSync", ctx, syncPeers)
	ret0, _ := ret[0].(error)
	return ret0
}

// FullSync indicates an expected call of FullSync.
func (mr *MocksyncRunnerMockRecorder) FullSync(ctx, syncPeers any) *MocksyncRunnerFullSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FullSync", reflect.TypeOf((*MocksyncRunner)(nil).FullSync), ctx, syncPeers)
	return &MocksyncRunnerFullSyncCall{Call: call}
}

// MocksyncRunnerFullSyncCall wrap *gomock.Call
type MocksyncRunnerFullSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncRunnerFullSyncCall) Return(arg0 error) *MocksyncRunnerFullSyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncRunnerFullSyncCall) Do(f func(context.Context, []p2p.Peer) error) *MocksyncRunnerFullSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncRunnerFullSyncCall) DoAndReturn(f func(context.Context, []p2p.Peer) error) *MocksyncRunnerFullSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SplitSync mocks base method.
func (m *MocksyncRunner) SplitSync(ctx context.Context, syncPeers []p2p.Peer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SplitSync", ctx, syncPeers)
	ret0, _ := ret[0].(error)
	return ret0
}

// SplitSync indicates an expected call of SplitSync.
func (mr *MocksyncRunnerMockRecorder) SplitSync(ctx, syncPeers any) *MocksyncRunnerSplitSyncCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SplitSync", reflect.TypeOf((*MocksyncRunner)(nil).SplitSync), ctx, syncPeers)
	return &MocksyncRunnerSplitSyncCall{Call: call}
}

// MocksyncRunnerSplitSyncCall wrap *gomock.Call
type MocksyncRunnerSplitSyncCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncRunnerSplitSyncCall) Return(arg0 error) *MocksyncRunnerSplitSyncCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncRunnerSplitSyncCall) Do(f func(context.Context, []p2p.Peer) error) *MocksyncRunnerSplitSyncCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncRunnerSplitSyncCall) DoAndReturn(f func(context.Context, []p2p.Peer) error) *MocksyncRunnerSplitSyncCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
