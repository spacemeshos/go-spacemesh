// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=mocks -destination=./mocks/mocks.go -source=./interface.go
//
// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	types "github.com/spacemeshos/go-spacemesh/common/types"
	gomock "go.uber.org/mock/gomock"
)

// MocklayerPatrol is a mock of layerPatrol interface.
type MocklayerPatrol struct {
	ctrl     *gomock.Controller
	recorder *MocklayerPatrolMockRecorder
}

// MocklayerPatrolMockRecorder is the mock recorder for MocklayerPatrol.
type MocklayerPatrolMockRecorder struct {
	mock *MocklayerPatrol
}

// NewMocklayerPatrol creates a new mock instance.
func NewMocklayerPatrol(ctrl *gomock.Controller) *MocklayerPatrol {
	mock := &MocklayerPatrol{ctrl: ctrl}
	mock.recorder = &MocklayerPatrolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocklayerPatrol) EXPECT() *MocklayerPatrolMockRecorder {
	return m.recorder
}

// CompleteHare mocks base method.
func (m *MocklayerPatrol) CompleteHare(arg0 types.LayerID) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CompleteHare", arg0)
}

// CompleteHare indicates an expected call of CompleteHare.
func (mr *MocklayerPatrolMockRecorder) CompleteHare(arg0 any) *layerPatrolCompleteHareCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompleteHare", reflect.TypeOf((*MocklayerPatrol)(nil).CompleteHare), arg0)
	return &layerPatrolCompleteHareCall{Call: call}
}

// layerPatrolCompleteHareCall wrap *gomock.Call
type layerPatrolCompleteHareCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerPatrolCompleteHareCall) Return() *layerPatrolCompleteHareCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerPatrolCompleteHareCall) Do(f func(types.LayerID)) *layerPatrolCompleteHareCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerPatrolCompleteHareCall) DoAndReturn(f func(types.LayerID)) *layerPatrolCompleteHareCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockmeshProvider is a mock of meshProvider interface.
type MockmeshProvider struct {
	ctrl     *gomock.Controller
	recorder *MockmeshProviderMockRecorder
}

// MockmeshProviderMockRecorder is the mock recorder for MockmeshProvider.
type MockmeshProviderMockRecorder struct {
	mock *MockmeshProvider
}

// NewMockmeshProvider creates a new mock instance.
func NewMockmeshProvider(ctrl *gomock.Controller) *MockmeshProvider {
	mock := &MockmeshProvider{ctrl: ctrl}
	mock.recorder = &MockmeshProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmeshProvider) EXPECT() *MockmeshProviderMockRecorder {
	return m.recorder
}

// AddBlockWithTXs mocks base method.
func (m *MockmeshProvider) AddBlockWithTXs(arg0 context.Context, arg1 *types.Block) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddBlockWithTXs", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddBlockWithTXs indicates an expected call of AddBlockWithTXs.
func (mr *MockmeshProviderMockRecorder) AddBlockWithTXs(arg0, arg1 any) *meshProviderAddBlockWithTXsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBlockWithTXs", reflect.TypeOf((*MockmeshProvider)(nil).AddBlockWithTXs), arg0, arg1)
	return &meshProviderAddBlockWithTXsCall{Call: call}
}

// meshProviderAddBlockWithTXsCall wrap *gomock.Call
type meshProviderAddBlockWithTXsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshProviderAddBlockWithTXsCall) Return(arg0 error) *meshProviderAddBlockWithTXsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshProviderAddBlockWithTXsCall) Do(f func(context.Context, *types.Block) error) *meshProviderAddBlockWithTXsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshProviderAddBlockWithTXsCall) DoAndReturn(f func(context.Context, *types.Block) error) *meshProviderAddBlockWithTXsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProcessLayerPerHareOutput mocks base method.
func (m *MockmeshProvider) ProcessLayerPerHareOutput(arg0 context.Context, arg1 types.LayerID, arg2 types.BlockID, arg3 bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessLayerPerHareOutput", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// ProcessLayerPerHareOutput indicates an expected call of ProcessLayerPerHareOutput.
func (mr *MockmeshProviderMockRecorder) ProcessLayerPerHareOutput(arg0, arg1, arg2, arg3 any) *meshProviderProcessLayerPerHareOutputCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessLayerPerHareOutput", reflect.TypeOf((*MockmeshProvider)(nil).ProcessLayerPerHareOutput), arg0, arg1, arg2, arg3)
	return &meshProviderProcessLayerPerHareOutputCall{Call: call}
}

// meshProviderProcessLayerPerHareOutputCall wrap *gomock.Call
type meshProviderProcessLayerPerHareOutputCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshProviderProcessLayerPerHareOutputCall) Return(arg0 error) *meshProviderProcessLayerPerHareOutputCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshProviderProcessLayerPerHareOutputCall) Do(f func(context.Context, types.LayerID, types.BlockID, bool) error) *meshProviderProcessLayerPerHareOutputCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshProviderProcessLayerPerHareOutputCall) DoAndReturn(f func(context.Context, types.LayerID, types.BlockID, bool) error) *meshProviderProcessLayerPerHareOutputCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProcessedLayer mocks base method.
func (m *MockmeshProvider) ProcessedLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// ProcessedLayer indicates an expected call of ProcessedLayer.
func (mr *MockmeshProviderMockRecorder) ProcessedLayer() *meshProviderProcessedLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedLayer", reflect.TypeOf((*MockmeshProvider)(nil).ProcessedLayer))
	return &meshProviderProcessedLayerCall{Call: call}
}

// meshProviderProcessedLayerCall wrap *gomock.Call
type meshProviderProcessedLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshProviderProcessedLayerCall) Return(arg0 types.LayerID) *meshProviderProcessedLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshProviderProcessedLayerCall) Do(f func() types.LayerID) *meshProviderProcessedLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshProviderProcessedLayerCall) DoAndReturn(f func() types.LayerID) *meshProviderProcessedLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockexecutor is a mock of executor interface.
type Mockexecutor struct {
	ctrl     *gomock.Controller
	recorder *MockexecutorMockRecorder
}

// MockexecutorMockRecorder is the mock recorder for Mockexecutor.
type MockexecutorMockRecorder struct {
	mock *Mockexecutor
}

// NewMockexecutor creates a new mock instance.
func NewMockexecutor(ctrl *gomock.Controller) *Mockexecutor {
	mock := &Mockexecutor{ctrl: ctrl}
	mock.recorder = &MockexecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockexecutor) EXPECT() *MockexecutorMockRecorder {
	return m.recorder
}

// ExecuteOptimistic mocks base method.
func (m *Mockexecutor) ExecuteOptimistic(arg0 context.Context, arg1 types.LayerID, arg2 uint64, arg3 []types.AnyReward, arg4 []types.TransactionID) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteOptimistic", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteOptimistic indicates an expected call of ExecuteOptimistic.
func (mr *MockexecutorMockRecorder) ExecuteOptimistic(arg0, arg1, arg2, arg3, arg4 any) *executorExecuteOptimisticCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteOptimistic", reflect.TypeOf((*Mockexecutor)(nil).ExecuteOptimistic), arg0, arg1, arg2, arg3, arg4)
	return &executorExecuteOptimisticCall{Call: call}
}

// executorExecuteOptimisticCall wrap *gomock.Call
type executorExecuteOptimisticCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *executorExecuteOptimisticCall) Return(arg0 *types.Block, arg1 error) *executorExecuteOptimisticCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *executorExecuteOptimisticCall) Do(f func(context.Context, types.LayerID, uint64, []types.AnyReward, []types.TransactionID) (*types.Block, error)) *executorExecuteOptimisticCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *executorExecuteOptimisticCall) DoAndReturn(f func(context.Context, types.LayerID, uint64, []types.AnyReward, []types.TransactionID) (*types.Block, error)) *executorExecuteOptimisticCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocklayerClock is a mock of layerClock interface.
type MocklayerClock struct {
	ctrl     *gomock.Controller
	recorder *MocklayerClockMockRecorder
}

// MocklayerClockMockRecorder is the mock recorder for MocklayerClock.
type MocklayerClockMockRecorder struct {
	mock *MocklayerClock
}

// NewMocklayerClock creates a new mock instance.
func NewMocklayerClock(ctrl *gomock.Controller) *MocklayerClock {
	mock := &MocklayerClock{ctrl: ctrl}
	mock.recorder = &MocklayerClockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocklayerClock) EXPECT() *MocklayerClockMockRecorder {
	return m.recorder
}

// AwaitLayer mocks base method.
func (m *MocklayerClock) AwaitLayer(layerID types.LayerID) <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AwaitLayer", layerID)
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// AwaitLayer indicates an expected call of AwaitLayer.
func (mr *MocklayerClockMockRecorder) AwaitLayer(layerID any) *layerClockAwaitLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AwaitLayer", reflect.TypeOf((*MocklayerClock)(nil).AwaitLayer), layerID)
	return &layerClockAwaitLayerCall{Call: call}
}

// layerClockAwaitLayerCall wrap *gomock.Call
type layerClockAwaitLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerClockAwaitLayerCall) Return(arg0 <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerClockAwaitLayerCall) Do(f func(types.LayerID) <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerClockAwaitLayerCall) DoAndReturn(f func(types.LayerID) <-chan struct{}) *layerClockAwaitLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentLayer mocks base method.
func (m *MocklayerClock) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MocklayerClockMockRecorder) CurrentLayer() *layerClockCurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MocklayerClock)(nil).CurrentLayer))
	return &layerClockCurrentLayerCall{Call: call}
}

// layerClockCurrentLayerCall wrap *gomock.Call
type layerClockCurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *layerClockCurrentLayerCall) Return(arg0 types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *layerClockCurrentLayerCall) Do(f func() types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *layerClockCurrentLayerCall) DoAndReturn(f func() types.LayerID) *layerClockCurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockcertifier is a mock of certifier interface.
type Mockcertifier struct {
	ctrl     *gomock.Controller
	recorder *MockcertifierMockRecorder
}

// MockcertifierMockRecorder is the mock recorder for Mockcertifier.
type MockcertifierMockRecorder struct {
	mock *Mockcertifier
}

// NewMockcertifier creates a new mock instance.
func NewMockcertifier(ctrl *gomock.Controller) *Mockcertifier {
	mock := &Mockcertifier{ctrl: ctrl}
	mock.recorder = &MockcertifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockcertifier) EXPECT() *MockcertifierMockRecorder {
	return m.recorder
}

// CertifyIfEligible mocks base method.
func (m *Mockcertifier) CertifyIfEligible(arg0 context.Context, arg1 types.LayerID, arg2 types.BlockID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CertifyIfEligible", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CertifyIfEligible indicates an expected call of CertifyIfEligible.
func (mr *MockcertifierMockRecorder) CertifyIfEligible(arg0, arg1, arg2 any) *certifierCertifyIfEligibleCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertifyIfEligible", reflect.TypeOf((*Mockcertifier)(nil).CertifyIfEligible), arg0, arg1, arg2)
	return &certifierCertifyIfEligibleCall{Call: call}
}

// certifierCertifyIfEligibleCall wrap *gomock.Call
type certifierCertifyIfEligibleCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *certifierCertifyIfEligibleCall) Return(arg0 error) *certifierCertifyIfEligibleCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *certifierCertifyIfEligibleCall) Do(f func(context.Context, types.LayerID, types.BlockID) error) *certifierCertifyIfEligibleCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *certifierCertifyIfEligibleCall) DoAndReturn(f func(context.Context, types.LayerID, types.BlockID) error) *certifierCertifyIfEligibleCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RegisterForCert mocks base method.
func (m *Mockcertifier) RegisterForCert(arg0 context.Context, arg1 types.LayerID, arg2 types.BlockID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterForCert", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterForCert indicates an expected call of RegisterForCert.
func (mr *MockcertifierMockRecorder) RegisterForCert(arg0, arg1, arg2 any) *certifierRegisterForCertCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterForCert", reflect.TypeOf((*Mockcertifier)(nil).RegisterForCert), arg0, arg1, arg2)
	return &certifierRegisterForCertCall{Call: call}
}

// certifierRegisterForCertCall wrap *gomock.Call
type certifierRegisterForCertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *certifierRegisterForCertCall) Return(arg0 error) *certifierRegisterForCertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *certifierRegisterForCertCall) Do(f func(context.Context, types.LayerID, types.BlockID) error) *certifierRegisterForCertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *certifierRegisterForCertCall) DoAndReturn(f func(context.Context, types.LayerID, types.BlockID) error) *certifierRegisterForCertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktortoiseProvider is a mock of tortoiseProvider interface.
type MocktortoiseProvider struct {
	ctrl     *gomock.Controller
	recorder *MocktortoiseProviderMockRecorder
}

// MocktortoiseProviderMockRecorder is the mock recorder for MocktortoiseProvider.
type MocktortoiseProviderMockRecorder struct {
	mock *MocktortoiseProvider
}

// NewMocktortoiseProvider creates a new mock instance.
func NewMocktortoiseProvider(ctrl *gomock.Controller) *MocktortoiseProvider {
	mock := &MocktortoiseProvider{ctrl: ctrl}
	mock.recorder = &MocktortoiseProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktortoiseProvider) EXPECT() *MocktortoiseProviderMockRecorder {
	return m.recorder
}

// GetMissingActiveSet mocks base method.
func (m *MocktortoiseProvider) GetMissingActiveSet(arg0 types.EpochID, arg1 []types.ATXID) []types.ATXID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMissingActiveSet", arg0, arg1)
	ret0, _ := ret[0].([]types.ATXID)
	return ret0
}

// GetMissingActiveSet indicates an expected call of GetMissingActiveSet.
func (mr *MocktortoiseProviderMockRecorder) GetMissingActiveSet(arg0, arg1 any) *tortoiseProviderGetMissingActiveSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMissingActiveSet", reflect.TypeOf((*MocktortoiseProvider)(nil).GetMissingActiveSet), arg0, arg1)
	return &tortoiseProviderGetMissingActiveSetCall{Call: call}
}

// tortoiseProviderGetMissingActiveSetCall wrap *gomock.Call
type tortoiseProviderGetMissingActiveSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *tortoiseProviderGetMissingActiveSetCall) Return(arg0 []types.ATXID) *tortoiseProviderGetMissingActiveSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *tortoiseProviderGetMissingActiveSetCall) Do(f func(types.EpochID, []types.ATXID) []types.ATXID) *tortoiseProviderGetMissingActiveSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *tortoiseProviderGetMissingActiveSetCall) DoAndReturn(f func(types.EpochID, []types.ATXID) []types.ATXID) *tortoiseProviderGetMissingActiveSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
