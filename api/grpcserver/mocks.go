// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=grpcserver -destination=./mocks.go -source=./interface.go
//
// Package grpcserver is a generated GoMock package.
package grpcserver

import (
	context "context"
	reflect "reflect"
	time "time"

	network "github.com/libp2p/go-libp2p/core/network"
	multiaddr "github.com/multiformats/go-multiaddr"
	activation "github.com/spacemeshos/go-spacemesh/activation"
	types "github.com/spacemeshos/go-spacemesh/common/types"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	system "github.com/spacemeshos/go-spacemesh/system"
	gomock "go.uber.org/mock/gomock"
)

// MocknetworkInfo is a mock of networkInfo interface.
type MocknetworkInfo struct {
	ctrl     *gomock.Controller
	recorder *MocknetworkInfoMockRecorder
}

// MocknetworkInfoMockRecorder is the mock recorder for MocknetworkInfo.
type MocknetworkInfoMockRecorder struct {
	mock *MocknetworkInfo
}

// NewMocknetworkInfo creates a new mock instance.
func NewMocknetworkInfo(ctrl *gomock.Controller) *MocknetworkInfo {
	mock := &MocknetworkInfo{ctrl: ctrl}
	mock.recorder = &MocknetworkInfoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocknetworkInfo) EXPECT() *MocknetworkInfoMockRecorder {
	return m.recorder
}

// DHTServerEnabled mocks base method.
func (m *MocknetworkInfo) DHTServerEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DHTServerEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// DHTServerEnabled indicates an expected call of DHTServerEnabled.
func (mr *MocknetworkInfoMockRecorder) DHTServerEnabled() *networkInfoDHTServerEnabledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DHTServerEnabled", reflect.TypeOf((*MocknetworkInfo)(nil).DHTServerEnabled))
	return &networkInfoDHTServerEnabledCall{Call: call}
}

// networkInfoDHTServerEnabledCall wrap *gomock.Call
type networkInfoDHTServerEnabledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoDHTServerEnabledCall) Return(arg0 bool) *networkInfoDHTServerEnabledCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoDHTServerEnabledCall) Do(f func() bool) *networkInfoDHTServerEnabledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoDHTServerEnabledCall) DoAndReturn(f func() bool) *networkInfoDHTServerEnabledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ID mocks base method.
func (m *MocknetworkInfo) ID() p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(p2p.Peer)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MocknetworkInfoMockRecorder) ID() *networkInfoIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MocknetworkInfo)(nil).ID))
	return &networkInfoIDCall{Call: call}
}

// networkInfoIDCall wrap *gomock.Call
type networkInfoIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoIDCall) Return(arg0 p2p.Peer) *networkInfoIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoIDCall) Do(f func() p2p.Peer) *networkInfoIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoIDCall) DoAndReturn(f func() p2p.Peer) *networkInfoIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// KnownAddresses mocks base method.
func (m *MocknetworkInfo) KnownAddresses() []multiaddr.Multiaddr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KnownAddresses")
	ret0, _ := ret[0].([]multiaddr.Multiaddr)
	return ret0
}

// KnownAddresses indicates an expected call of KnownAddresses.
func (mr *MocknetworkInfoMockRecorder) KnownAddresses() *networkInfoKnownAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KnownAddresses", reflect.TypeOf((*MocknetworkInfo)(nil).KnownAddresses))
	return &networkInfoKnownAddressesCall{Call: call}
}

// networkInfoKnownAddressesCall wrap *gomock.Call
type networkInfoKnownAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoKnownAddressesCall) Return(arg0 []multiaddr.Multiaddr) *networkInfoKnownAddressesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoKnownAddressesCall) Do(f func() []multiaddr.Multiaddr) *networkInfoKnownAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoKnownAddressesCall) DoAndReturn(f func() []multiaddr.Multiaddr) *networkInfoKnownAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListenAddresses mocks base method.
func (m *MocknetworkInfo) ListenAddresses() []multiaddr.Multiaddr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListenAddresses")
	ret0, _ := ret[0].([]multiaddr.Multiaddr)
	return ret0
}

// ListenAddresses indicates an expected call of ListenAddresses.
func (mr *MocknetworkInfoMockRecorder) ListenAddresses() *networkInfoListenAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenAddresses", reflect.TypeOf((*MocknetworkInfo)(nil).ListenAddresses))
	return &networkInfoListenAddressesCall{Call: call}
}

// networkInfoListenAddressesCall wrap *gomock.Call
type networkInfoListenAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoListenAddressesCall) Return(arg0 []multiaddr.Multiaddr) *networkInfoListenAddressesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoListenAddressesCall) Do(f func() []multiaddr.Multiaddr) *networkInfoListenAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoListenAddressesCall) DoAndReturn(f func() []multiaddr.Multiaddr) *networkInfoListenAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NATDeviceType mocks base method.
func (m *MocknetworkInfo) NATDeviceType() (network.NATDeviceType, network.NATDeviceType) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NATDeviceType")
	ret0, _ := ret[0].(network.NATDeviceType)
	ret1, _ := ret[1].(network.NATDeviceType)
	return ret0, ret1
}

// NATDeviceType indicates an expected call of NATDeviceType.
func (mr *MocknetworkInfoMockRecorder) NATDeviceType() *networkInfoNATDeviceTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NATDeviceType", reflect.TypeOf((*MocknetworkInfo)(nil).NATDeviceType))
	return &networkInfoNATDeviceTypeCall{Call: call}
}

// networkInfoNATDeviceTypeCall wrap *gomock.Call
type networkInfoNATDeviceTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoNATDeviceTypeCall) Return(udpNATType, tcpNATType network.NATDeviceType) *networkInfoNATDeviceTypeCall {
	c.Call = c.Call.Return(udpNATType, tcpNATType)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoNATDeviceTypeCall) Do(f func() (network.NATDeviceType, network.NATDeviceType)) *networkInfoNATDeviceTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoNATDeviceTypeCall) DoAndReturn(f func() (network.NATDeviceType, network.NATDeviceType)) *networkInfoNATDeviceTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Reachability mocks base method.
func (m *MocknetworkInfo) Reachability() network.Reachability {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reachability")
	ret0, _ := ret[0].(network.Reachability)
	return ret0
}

// Reachability indicates an expected call of Reachability.
func (mr *MocknetworkInfoMockRecorder) Reachability() *networkInfoReachabilityCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reachability", reflect.TypeOf((*MocknetworkInfo)(nil).Reachability))
	return &networkInfoReachabilityCall{Call: call}
}

// networkInfoReachabilityCall wrap *gomock.Call
type networkInfoReachabilityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *networkInfoReachabilityCall) Return(arg0 network.Reachability) *networkInfoReachabilityCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *networkInfoReachabilityCall) Do(f func() network.Reachability) *networkInfoReachabilityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *networkInfoReachabilityCall) DoAndReturn(f func() network.Reachability) *networkInfoReachabilityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockconservativeState is a mock of conservativeState interface.
type MockconservativeState struct {
	ctrl     *gomock.Controller
	recorder *MockconservativeStateMockRecorder
}

// MockconservativeStateMockRecorder is the mock recorder for MockconservativeState.
type MockconservativeStateMockRecorder struct {
	mock *MockconservativeState
}

// NewMockconservativeState creates a new mock instance.
func NewMockconservativeState(ctrl *gomock.Controller) *MockconservativeState {
	mock := &MockconservativeState{ctrl: ctrl}
	mock.recorder = &MockconservativeStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockconservativeState) EXPECT() *MockconservativeStateMockRecorder {
	return m.recorder
}

// GetAllAccounts mocks base method.
func (m *MockconservativeState) GetAllAccounts() ([]*types.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllAccounts")
	ret0, _ := ret[0].([]*types.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllAccounts indicates an expected call of GetAllAccounts.
func (mr *MockconservativeStateMockRecorder) GetAllAccounts() *conservativeStateGetAllAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllAccounts", reflect.TypeOf((*MockconservativeState)(nil).GetAllAccounts))
	return &conservativeStateGetAllAccountsCall{Call: call}
}

// conservativeStateGetAllAccountsCall wrap *gomock.Call
type conservativeStateGetAllAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetAllAccountsCall) Return(arg0 []*types.Account, arg1 error) *conservativeStateGetAllAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetAllAccountsCall) Do(f func() ([]*types.Account, error)) *conservativeStateGetAllAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetAllAccountsCall) DoAndReturn(f func() ([]*types.Account, error)) *conservativeStateGetAllAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockconservativeState) GetBalance(arg0 types.Address) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockconservativeStateMockRecorder) GetBalance(arg0 any) *conservativeStateGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockconservativeState)(nil).GetBalance), arg0)
	return &conservativeStateGetBalanceCall{Call: call}
}

// conservativeStateGetBalanceCall wrap *gomock.Call
type conservativeStateGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetBalanceCall) Return(arg0 uint64, arg1 error) *conservativeStateGetBalanceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetBalanceCall) Do(f func(types.Address) (uint64, error)) *conservativeStateGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetBalanceCall) DoAndReturn(f func(types.Address) (uint64, error)) *conservativeStateGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLayerStateRoot mocks base method.
func (m *MockconservativeState) GetLayerStateRoot(arg0 types.LayerID) (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayerStateRoot", arg0)
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayerStateRoot indicates an expected call of GetLayerStateRoot.
func (mr *MockconservativeStateMockRecorder) GetLayerStateRoot(arg0 any) *conservativeStateGetLayerStateRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayerStateRoot", reflect.TypeOf((*MockconservativeState)(nil).GetLayerStateRoot), arg0)
	return &conservativeStateGetLayerStateRootCall{Call: call}
}

// conservativeStateGetLayerStateRootCall wrap *gomock.Call
type conservativeStateGetLayerStateRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetLayerStateRootCall) Return(arg0 types.Hash32, arg1 error) *conservativeStateGetLayerStateRootCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetLayerStateRootCall) Do(f func(types.LayerID) (types.Hash32, error)) *conservativeStateGetLayerStateRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetLayerStateRootCall) DoAndReturn(f func(types.LayerID) (types.Hash32, error)) *conservativeStateGetLayerStateRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeshTransaction mocks base method.
func (m *MockconservativeState) GetMeshTransaction(arg0 types.TransactionID) (*types.MeshTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeshTransaction", arg0)
	ret0, _ := ret[0].(*types.MeshTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMeshTransaction indicates an expected call of GetMeshTransaction.
func (mr *MockconservativeStateMockRecorder) GetMeshTransaction(arg0 any) *conservativeStateGetMeshTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeshTransaction", reflect.TypeOf((*MockconservativeState)(nil).GetMeshTransaction), arg0)
	return &conservativeStateGetMeshTransactionCall{Call: call}
}

// conservativeStateGetMeshTransactionCall wrap *gomock.Call
type conservativeStateGetMeshTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetMeshTransactionCall) Return(arg0 *types.MeshTransaction, arg1 error) *conservativeStateGetMeshTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetMeshTransactionCall) Do(f func(types.TransactionID) (*types.MeshTransaction, error)) *conservativeStateGetMeshTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetMeshTransactionCall) DoAndReturn(f func(types.TransactionID) (*types.MeshTransaction, error)) *conservativeStateGetMeshTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeshTransactions mocks base method.
func (m *MockconservativeState) GetMeshTransactions(arg0 []types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{}) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeshTransactions", arg0)
	ret0, _ := ret[0].([]*types.MeshTransaction)
	ret1, _ := ret[1].(map[types.TransactionID]struct{})
	return ret0, ret1
}

// GetMeshTransactions indicates an expected call of GetMeshTransactions.
func (mr *MockconservativeStateMockRecorder) GetMeshTransactions(arg0 any) *conservativeStateGetMeshTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeshTransactions", reflect.TypeOf((*MockconservativeState)(nil).GetMeshTransactions), arg0)
	return &conservativeStateGetMeshTransactionsCall{Call: call}
}

// conservativeStateGetMeshTransactionsCall wrap *gomock.Call
type conservativeStateGetMeshTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetMeshTransactionsCall) Return(arg0 []*types.MeshTransaction, arg1 map[types.TransactionID]struct{}) *conservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetMeshTransactionsCall) Do(f func([]types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{})) *conservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetMeshTransactionsCall) DoAndReturn(f func([]types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{})) *conservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockconservativeState) GetNonce(arg0 types.Address) (types.Nonce, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(types.Nonce)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockconservativeStateMockRecorder) GetNonce(arg0 any) *conservativeStateGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockconservativeState)(nil).GetNonce), arg0)
	return &conservativeStateGetNonceCall{Call: call}
}

// conservativeStateGetNonceCall wrap *gomock.Call
type conservativeStateGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetNonceCall) Return(arg0 types.Nonce, arg1 error) *conservativeStateGetNonceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetNonceCall) Do(f func(types.Address) (types.Nonce, error)) *conservativeStateGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetNonceCall) DoAndReturn(f func(types.Address) (types.Nonce, error)) *conservativeStateGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjection mocks base method.
func (m *MockconservativeState) GetProjection(arg0 types.Address) (uint64, uint64) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProjection", arg0)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	return ret0, ret1
}

// GetProjection indicates an expected call of GetProjection.
func (mr *MockconservativeStateMockRecorder) GetProjection(arg0 any) *conservativeStateGetProjectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjection", reflect.TypeOf((*MockconservativeState)(nil).GetProjection), arg0)
	return &conservativeStateGetProjectionCall{Call: call}
}

// conservativeStateGetProjectionCall wrap *gomock.Call
type conservativeStateGetProjectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetProjectionCall) Return(arg0, arg1 uint64) *conservativeStateGetProjectionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetProjectionCall) Do(f func(types.Address) (uint64, uint64)) *conservativeStateGetProjectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetProjectionCall) DoAndReturn(f func(types.Address) (uint64, uint64)) *conservativeStateGetProjectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStateRoot mocks base method.
func (m *MockconservativeState) GetStateRoot() (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStateRoot")
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStateRoot indicates an expected call of GetStateRoot.
func (mr *MockconservativeStateMockRecorder) GetStateRoot() *conservativeStateGetStateRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStateRoot", reflect.TypeOf((*MockconservativeState)(nil).GetStateRoot))
	return &conservativeStateGetStateRootCall{Call: call}
}

// conservativeStateGetStateRootCall wrap *gomock.Call
type conservativeStateGetStateRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetStateRootCall) Return(arg0 types.Hash32, arg1 error) *conservativeStateGetStateRootCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetStateRootCall) Do(f func() (types.Hash32, error)) *conservativeStateGetStateRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetStateRootCall) DoAndReturn(f func() (types.Hash32, error)) *conservativeStateGetStateRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionsByAddress mocks base method.
func (m *MockconservativeState) GetTransactionsByAddress(arg0, arg1 types.LayerID, arg2 types.Address) ([]*types.MeshTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionsByAddress", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*types.MeshTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionsByAddress indicates an expected call of GetTransactionsByAddress.
func (mr *MockconservativeStateMockRecorder) GetTransactionsByAddress(arg0, arg1, arg2 any) *conservativeStateGetTransactionsByAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionsByAddress", reflect.TypeOf((*MockconservativeState)(nil).GetTransactionsByAddress), arg0, arg1, arg2)
	return &conservativeStateGetTransactionsByAddressCall{Call: call}
}

// conservativeStateGetTransactionsByAddressCall wrap *gomock.Call
type conservativeStateGetTransactionsByAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateGetTransactionsByAddressCall) Return(arg0 []*types.MeshTransaction, arg1 error) *conservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateGetTransactionsByAddressCall) Do(f func(types.LayerID, types.LayerID, types.Address) ([]*types.MeshTransaction, error)) *conservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateGetTransactionsByAddressCall) DoAndReturn(f func(types.LayerID, types.LayerID, types.Address) ([]*types.MeshTransaction, error)) *conservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Validation mocks base method.
func (m *MockconservativeState) Validation(raw types.RawTx) system.ValidationRequest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validation", raw)
	ret0, _ := ret[0].(system.ValidationRequest)
	return ret0
}

// Validation indicates an expected call of Validation.
func (mr *MockconservativeStateMockRecorder) Validation(raw any) *conservativeStateValidationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validation", reflect.TypeOf((*MockconservativeState)(nil).Validation), raw)
	return &conservativeStateValidationCall{Call: call}
}

// conservativeStateValidationCall wrap *gomock.Call
type conservativeStateValidationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *conservativeStateValidationCall) Return(arg0 system.ValidationRequest) *conservativeStateValidationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *conservativeStateValidationCall) Do(f func(types.RawTx) system.ValidationRequest) *conservativeStateValidationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *conservativeStateValidationCall) DoAndReturn(f func(types.RawTx) system.ValidationRequest) *conservativeStateValidationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mocksyncer is a mock of syncer interface.
type Mocksyncer struct {
	ctrl     *gomock.Controller
	recorder *MocksyncerMockRecorder
}

// MocksyncerMockRecorder is the mock recorder for Mocksyncer.
type MocksyncerMockRecorder struct {
	mock *Mocksyncer
}

// NewMocksyncer creates a new mock instance.
func NewMocksyncer(ctrl *gomock.Controller) *Mocksyncer {
	mock := &Mocksyncer{ctrl: ctrl}
	mock.recorder = &MocksyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocksyncer) EXPECT() *MocksyncerMockRecorder {
	return m.recorder
}

// IsSynced mocks base method.
func (m *Mocksyncer) IsSynced(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSynced", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSynced indicates an expected call of IsSynced.
func (mr *MocksyncerMockRecorder) IsSynced(arg0 any) *syncerIsSyncedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSynced", reflect.TypeOf((*Mocksyncer)(nil).IsSynced), arg0)
	return &syncerIsSyncedCall{Call: call}
}

// syncerIsSyncedCall wrap *gomock.Call
type syncerIsSyncedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *syncerIsSyncedCall) Return(arg0 bool) *syncerIsSyncedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *syncerIsSyncedCall) Do(f func(context.Context) bool) *syncerIsSyncedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *syncerIsSyncedCall) DoAndReturn(f func(context.Context) bool) *syncerIsSyncedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxValidator is a mock of txValidator interface.
type MocktxValidator struct {
	ctrl     *gomock.Controller
	recorder *MocktxValidatorMockRecorder
}

// MocktxValidatorMockRecorder is the mock recorder for MocktxValidator.
type MocktxValidatorMockRecorder struct {
	mock *MocktxValidator
}

// NewMocktxValidator creates a new mock instance.
func NewMocktxValidator(ctrl *gomock.Controller) *MocktxValidator {
	mock := &MocktxValidator{ctrl: ctrl}
	mock.recorder = &MocktxValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxValidator) EXPECT() *MocktxValidatorMockRecorder {
	return m.recorder
}

// VerifyAndCacheTx mocks base method.
func (m *MocktxValidator) VerifyAndCacheTx(arg0 context.Context, arg1 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyAndCacheTx", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyAndCacheTx indicates an expected call of VerifyAndCacheTx.
func (mr *MocktxValidatorMockRecorder) VerifyAndCacheTx(arg0, arg1 any) *txValidatorVerifyAndCacheTxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyAndCacheTx", reflect.TypeOf((*MocktxValidator)(nil).VerifyAndCacheTx), arg0, arg1)
	return &txValidatorVerifyAndCacheTxCall{Call: call}
}

// txValidatorVerifyAndCacheTxCall wrap *gomock.Call
type txValidatorVerifyAndCacheTxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txValidatorVerifyAndCacheTxCall) Return(arg0 error) *txValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txValidatorVerifyAndCacheTxCall) Do(f func(context.Context, []byte) error) *txValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txValidatorVerifyAndCacheTxCall) DoAndReturn(f func(context.Context, []byte) error) *txValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockatxProvider is a mock of atxProvider interface.
type MockatxProvider struct {
	ctrl     *gomock.Controller
	recorder *MockatxProviderMockRecorder
}

// MockatxProviderMockRecorder is the mock recorder for MockatxProvider.
type MockatxProviderMockRecorder struct {
	mock *MockatxProvider
}

// NewMockatxProvider creates a new mock instance.
func NewMockatxProvider(ctrl *gomock.Controller) *MockatxProvider {
	mock := &MockatxProvider{ctrl: ctrl}
	mock.recorder = &MockatxProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockatxProvider) EXPECT() *MockatxProviderMockRecorder {
	return m.recorder
}

// GetFullAtx mocks base method.
func (m *MockatxProvider) GetFullAtx(id types.ATXID) (*types.VerifiedActivationTx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetFullAtx", id)
	ret0, _ := ret[0].(*types.VerifiedActivationTx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetFullAtx indicates an expected call of GetFullAtx.
func (mr *MockatxProviderMockRecorder) GetFullAtx(id any) *atxProviderGetFullAtxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetFullAtx", reflect.TypeOf((*MockatxProvider)(nil).GetFullAtx), id)
	return &atxProviderGetFullAtxCall{Call: call}
}

// atxProviderGetFullAtxCall wrap *gomock.Call
type atxProviderGetFullAtxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *atxProviderGetFullAtxCall) Return(arg0 *types.VerifiedActivationTx, arg1 error) *atxProviderGetFullAtxCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *atxProviderGetFullAtxCall) Do(f func(types.ATXID) (*types.VerifiedActivationTx, error)) *atxProviderGetFullAtxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *atxProviderGetFullAtxCall) DoAndReturn(f func(types.ATXID) (*types.VerifiedActivationTx, error)) *atxProviderGetFullAtxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMalfeasanceProof mocks base method.
func (m *MockatxProvider) GetMalfeasanceProof(id types.NodeID) (*types.MalfeasanceProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMalfeasanceProof", id)
	ret0, _ := ret[0].(*types.MalfeasanceProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMalfeasanceProof indicates an expected call of GetMalfeasanceProof.
func (mr *MockatxProviderMockRecorder) GetMalfeasanceProof(id any) *atxProviderGetMalfeasanceProofCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMalfeasanceProof", reflect.TypeOf((*MockatxProvider)(nil).GetMalfeasanceProof), id)
	return &atxProviderGetMalfeasanceProofCall{Call: call}
}

// atxProviderGetMalfeasanceProofCall wrap *gomock.Call
type atxProviderGetMalfeasanceProofCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *atxProviderGetMalfeasanceProofCall) Return(arg0 *types.MalfeasanceProof, arg1 error) *atxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *atxProviderGetMalfeasanceProofCall) Do(f func(types.NodeID) (*types.MalfeasanceProof, error)) *atxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *atxProviderGetMalfeasanceProofCall) DoAndReturn(f func(types.NodeID) (*types.MalfeasanceProof, error)) *atxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MaxHeightAtx mocks base method.
func (m *MockatxProvider) MaxHeightAtx() (types.ATXID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaxHeightAtx")
	ret0, _ := ret[0].(types.ATXID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MaxHeightAtx indicates an expected call of MaxHeightAtx.
func (mr *MockatxProviderMockRecorder) MaxHeightAtx() *atxProviderMaxHeightAtxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaxHeightAtx", reflect.TypeOf((*MockatxProvider)(nil).MaxHeightAtx))
	return &atxProviderMaxHeightAtxCall{Call: call}
}

// atxProviderMaxHeightAtxCall wrap *gomock.Call
type atxProviderMaxHeightAtxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *atxProviderMaxHeightAtxCall) Return(arg0 types.ATXID, arg1 error) *atxProviderMaxHeightAtxCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *atxProviderMaxHeightAtxCall) Do(f func() (types.ATXID, error)) *atxProviderMaxHeightAtxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *atxProviderMaxHeightAtxCall) DoAndReturn(f func() (types.ATXID, error)) *atxProviderMaxHeightAtxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpostSetupProvider is a mock of postSetupProvider interface.
type MockpostSetupProvider struct {
	ctrl     *gomock.Controller
	recorder *MockpostSetupProviderMockRecorder
}

// MockpostSetupProviderMockRecorder is the mock recorder for MockpostSetupProvider.
type MockpostSetupProviderMockRecorder struct {
	mock *MockpostSetupProvider
}

// NewMockpostSetupProvider creates a new mock instance.
func NewMockpostSetupProvider(ctrl *gomock.Controller) *MockpostSetupProvider {
	mock := &MockpostSetupProvider{ctrl: ctrl}
	mock.recorder = &MockpostSetupProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpostSetupProvider) EXPECT() *MockpostSetupProviderMockRecorder {
	return m.recorder
}

// Benchmark mocks base method.
func (m *MockpostSetupProvider) Benchmark(p activation.PostSetupProvider) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Benchmark", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Benchmark indicates an expected call of Benchmark.
func (mr *MockpostSetupProviderMockRecorder) Benchmark(p any) *postSetupProviderBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Benchmark", reflect.TypeOf((*MockpostSetupProvider)(nil).Benchmark), p)
	return &postSetupProviderBenchmarkCall{Call: call}
}

// postSetupProviderBenchmarkCall wrap *gomock.Call
type postSetupProviderBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *postSetupProviderBenchmarkCall) Return(arg0 int, arg1 error) *postSetupProviderBenchmarkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *postSetupProviderBenchmarkCall) Do(f func(activation.PostSetupProvider) (int, error)) *postSetupProviderBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *postSetupProviderBenchmarkCall) DoAndReturn(f func(activation.PostSetupProvider) (int, error)) *postSetupProviderBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockpostSetupProvider) Config() activation.PostConfig {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(activation.PostConfig)
	return ret0
}

// Config indicates an expected call of Config.
func (mr *MockpostSetupProviderMockRecorder) Config() *postSetupProviderConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockpostSetupProvider)(nil).Config))
	return &postSetupProviderConfigCall{Call: call}
}

// postSetupProviderConfigCall wrap *gomock.Call
type postSetupProviderConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *postSetupProviderConfigCall) Return(arg0 activation.PostConfig) *postSetupProviderConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *postSetupProviderConfigCall) Do(f func() activation.PostConfig) *postSetupProviderConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *postSetupProviderConfigCall) DoAndReturn(f func() activation.PostConfig) *postSetupProviderConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Providers mocks base method.
func (m *MockpostSetupProvider) Providers() ([]activation.PostSetupProvider, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Providers")
	ret0, _ := ret[0].([]activation.PostSetupProvider)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Providers indicates an expected call of Providers.
func (mr *MockpostSetupProviderMockRecorder) Providers() *postSetupProviderProvidersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Providers", reflect.TypeOf((*MockpostSetupProvider)(nil).Providers))
	return &postSetupProviderProvidersCall{Call: call}
}

// postSetupProviderProvidersCall wrap *gomock.Call
type postSetupProviderProvidersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *postSetupProviderProvidersCall) Return(arg0 []activation.PostSetupProvider, arg1 error) *postSetupProviderProvidersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *postSetupProviderProvidersCall) Do(f func() ([]activation.PostSetupProvider, error)) *postSetupProviderProvidersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *postSetupProviderProvidersCall) DoAndReturn(f func() ([]activation.PostSetupProvider, error)) *postSetupProviderProvidersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockpostSetupProvider) Status() *activation.PostSetupStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(*activation.PostSetupStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockpostSetupProviderMockRecorder) Status() *postSetupProviderStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockpostSetupProvider)(nil).Status))
	return &postSetupProviderStatusCall{Call: call}
}

// postSetupProviderStatusCall wrap *gomock.Call
type postSetupProviderStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *postSetupProviderStatusCall) Return(arg0 *activation.PostSetupStatus) *postSetupProviderStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *postSetupProviderStatusCall) Do(f func() *activation.PostSetupStatus) *postSetupProviderStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *postSetupProviderStatusCall) DoAndReturn(f func() *activation.PostSetupStatus) *postSetupProviderStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpeerCounter is a mock of peerCounter interface.
type MockpeerCounter struct {
	ctrl     *gomock.Controller
	recorder *MockpeerCounterMockRecorder
}

// MockpeerCounterMockRecorder is the mock recorder for MockpeerCounter.
type MockpeerCounterMockRecorder struct {
	mock *MockpeerCounter
}

// NewMockpeerCounter creates a new mock instance.
func NewMockpeerCounter(ctrl *gomock.Controller) *MockpeerCounter {
	mock := &MockpeerCounter{ctrl: ctrl}
	mock.recorder = &MockpeerCounterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpeerCounter) EXPECT() *MockpeerCounterMockRecorder {
	return m.recorder
}

// PeerCount mocks base method.
func (m *MockpeerCounter) PeerCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeerCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PeerCount indicates an expected call of PeerCount.
func (mr *MockpeerCounterMockRecorder) PeerCount() *peerCounterPeerCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeerCount", reflect.TypeOf((*MockpeerCounter)(nil).PeerCount))
	return &peerCounterPeerCountCall{Call: call}
}

// peerCounterPeerCountCall wrap *gomock.Call
type peerCounterPeerCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *peerCounterPeerCountCall) Return(arg0 uint64) *peerCounterPeerCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *peerCounterPeerCountCall) Do(f func() uint64) *peerCounterPeerCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *peerCounterPeerCountCall) DoAndReturn(f func() uint64) *peerCounterPeerCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockpeers is a mock of peers interface.
type Mockpeers struct {
	ctrl     *gomock.Controller
	recorder *MockpeersMockRecorder
}

// MockpeersMockRecorder is the mock recorder for Mockpeers.
type MockpeersMockRecorder struct {
	mock *Mockpeers
}

// NewMockpeers creates a new mock instance.
func NewMockpeers(ctrl *gomock.Controller) *Mockpeers {
	mock := &Mockpeers{ctrl: ctrl}
	mock.recorder = &MockpeersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockpeers) EXPECT() *MockpeersMockRecorder {
	return m.recorder
}

// ConnectedPeerInfo mocks base method.
func (m *Mockpeers) ConnectedPeerInfo(arg0 p2p.Peer) *p2p.PeerInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConnectedPeerInfo", arg0)
	ret0, _ := ret[0].(*p2p.PeerInfo)
	return ret0
}

// ConnectedPeerInfo indicates an expected call of ConnectedPeerInfo.
func (mr *MockpeersMockRecorder) ConnectedPeerInfo(arg0 any) *peersConnectedPeerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectedPeerInfo", reflect.TypeOf((*Mockpeers)(nil).ConnectedPeerInfo), arg0)
	return &peersConnectedPeerInfoCall{Call: call}
}

// peersConnectedPeerInfoCall wrap *gomock.Call
type peersConnectedPeerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *peersConnectedPeerInfoCall) Return(arg0 *p2p.PeerInfo) *peersConnectedPeerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *peersConnectedPeerInfoCall) Do(f func(p2p.Peer) *p2p.PeerInfo) *peersConnectedPeerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *peersConnectedPeerInfoCall) DoAndReturn(f func(p2p.Peer) *p2p.PeerInfo) *peersConnectedPeerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPeers mocks base method.
func (m *Mockpeers) GetPeers() []p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPeers")
	ret0, _ := ret[0].([]p2p.Peer)
	return ret0
}

// GetPeers indicates an expected call of GetPeers.
func (mr *MockpeersMockRecorder) GetPeers() *peersGetPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPeers", reflect.TypeOf((*Mockpeers)(nil).GetPeers))
	return &peersGetPeersCall{Call: call}
}

// peersGetPeersCall wrap *gomock.Call
type peersGetPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *peersGetPeersCall) Return(arg0 []p2p.Peer) *peersGetPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *peersGetPeersCall) Do(f func() []p2p.Peer) *peersGetPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *peersGetPeersCall) DoAndReturn(f func() []p2p.Peer) *peersGetPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockgenesisTimeAPI is a mock of genesisTimeAPI interface.
type MockgenesisTimeAPI struct {
	ctrl     *gomock.Controller
	recorder *MockgenesisTimeAPIMockRecorder
}

// MockgenesisTimeAPIMockRecorder is the mock recorder for MockgenesisTimeAPI.
type MockgenesisTimeAPIMockRecorder struct {
	mock *MockgenesisTimeAPI
}

// NewMockgenesisTimeAPI creates a new mock instance.
func NewMockgenesisTimeAPI(ctrl *gomock.Controller) *MockgenesisTimeAPI {
	mock := &MockgenesisTimeAPI{ctrl: ctrl}
	mock.recorder = &MockgenesisTimeAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgenesisTimeAPI) EXPECT() *MockgenesisTimeAPIMockRecorder {
	return m.recorder
}

// CurrentLayer mocks base method.
func (m *MockgenesisTimeAPI) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MockgenesisTimeAPIMockRecorder) CurrentLayer() *genesisTimeAPICurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MockgenesisTimeAPI)(nil).CurrentLayer))
	return &genesisTimeAPICurrentLayerCall{Call: call}
}

// genesisTimeAPICurrentLayerCall wrap *gomock.Call
type genesisTimeAPICurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *genesisTimeAPICurrentLayerCall) Return(arg0 types.LayerID) *genesisTimeAPICurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *genesisTimeAPICurrentLayerCall) Do(f func() types.LayerID) *genesisTimeAPICurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *genesisTimeAPICurrentLayerCall) DoAndReturn(f func() types.LayerID) *genesisTimeAPICurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenesisTime mocks base method.
func (m *MockgenesisTimeAPI) GenesisTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenesisTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// GenesisTime indicates an expected call of GenesisTime.
func (mr *MockgenesisTimeAPIMockRecorder) GenesisTime() *genesisTimeAPIGenesisTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenesisTime", reflect.TypeOf((*MockgenesisTimeAPI)(nil).GenesisTime))
	return &genesisTimeAPIGenesisTimeCall{Call: call}
}

// genesisTimeAPIGenesisTimeCall wrap *gomock.Call
type genesisTimeAPIGenesisTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *genesisTimeAPIGenesisTimeCall) Return(arg0 time.Time) *genesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *genesisTimeAPIGenesisTimeCall) Do(f func() time.Time) *genesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *genesisTimeAPIGenesisTimeCall) DoAndReturn(f func() time.Time) *genesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockmeshAPI is a mock of meshAPI interface.
type MockmeshAPI struct {
	ctrl     *gomock.Controller
	recorder *MockmeshAPIMockRecorder
}

// MockmeshAPIMockRecorder is the mock recorder for MockmeshAPI.
type MockmeshAPIMockRecorder struct {
	mock *MockmeshAPI
}

// NewMockmeshAPI creates a new mock instance.
func NewMockmeshAPI(ctrl *gomock.Controller) *MockmeshAPI {
	mock := &MockmeshAPI{ctrl: ctrl}
	mock.recorder = &MockmeshAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmeshAPI) EXPECT() *MockmeshAPIMockRecorder {
	return m.recorder
}

// GetATXs mocks base method.
func (m *MockmeshAPI) GetATXs(arg0 context.Context, arg1 []types.ATXID) (map[types.ATXID]*types.VerifiedActivationTx, []types.ATXID) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetATXs", arg0, arg1)
	ret0, _ := ret[0].(map[types.ATXID]*types.VerifiedActivationTx)
	ret1, _ := ret[1].([]types.ATXID)
	return ret0, ret1
}

// GetATXs indicates an expected call of GetATXs.
func (mr *MockmeshAPIMockRecorder) GetATXs(arg0, arg1 any) *meshAPIGetATXsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetATXs", reflect.TypeOf((*MockmeshAPI)(nil).GetATXs), arg0, arg1)
	return &meshAPIGetATXsCall{Call: call}
}

// meshAPIGetATXsCall wrap *gomock.Call
type meshAPIGetATXsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPIGetATXsCall) Return(arg0 map[types.ATXID]*types.VerifiedActivationTx, arg1 []types.ATXID) *meshAPIGetATXsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPIGetATXsCall) Do(f func(context.Context, []types.ATXID) (map[types.ATXID]*types.VerifiedActivationTx, []types.ATXID)) *meshAPIGetATXsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPIGetATXsCall) DoAndReturn(f func(context.Context, []types.ATXID) (map[types.ATXID]*types.VerifiedActivationTx, []types.ATXID)) *meshAPIGetATXsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLayer mocks base method.
func (m *MockmeshAPI) GetLayer(arg0 types.LayerID) (*types.Layer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayer", arg0)
	ret0, _ := ret[0].(*types.Layer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayer indicates an expected call of GetLayer.
func (mr *MockmeshAPIMockRecorder) GetLayer(arg0 any) *meshAPIGetLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayer", reflect.TypeOf((*MockmeshAPI)(nil).GetLayer), arg0)
	return &meshAPIGetLayerCall{Call: call}
}

// meshAPIGetLayerCall wrap *gomock.Call
type meshAPIGetLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPIGetLayerCall) Return(arg0 *types.Layer, arg1 error) *meshAPIGetLayerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPIGetLayerCall) Do(f func(types.LayerID) (*types.Layer, error)) *meshAPIGetLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPIGetLayerCall) DoAndReturn(f func(types.LayerID) (*types.Layer, error)) *meshAPIGetLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRewards mocks base method.
func (m *MockmeshAPI) GetRewards(arg0 types.Address) ([]*types.Reward, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRewards", arg0)
	ret0, _ := ret[0].([]*types.Reward)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRewards indicates an expected call of GetRewards.
func (mr *MockmeshAPIMockRecorder) GetRewards(arg0 any) *meshAPIGetRewardsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRewards", reflect.TypeOf((*MockmeshAPI)(nil).GetRewards), arg0)
	return &meshAPIGetRewardsCall{Call: call}
}

// meshAPIGetRewardsCall wrap *gomock.Call
type meshAPIGetRewardsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPIGetRewardsCall) Return(arg0 []*types.Reward, arg1 error) *meshAPIGetRewardsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPIGetRewardsCall) Do(f func(types.Address) ([]*types.Reward, error)) *meshAPIGetRewardsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPIGetRewardsCall) DoAndReturn(f func(types.Address) ([]*types.Reward, error)) *meshAPIGetRewardsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LatestLayer mocks base method.
func (m *MockmeshAPI) LatestLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// LatestLayer indicates an expected call of LatestLayer.
func (mr *MockmeshAPIMockRecorder) LatestLayer() *meshAPILatestLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestLayer", reflect.TypeOf((*MockmeshAPI)(nil).LatestLayer))
	return &meshAPILatestLayerCall{Call: call}
}

// meshAPILatestLayerCall wrap *gomock.Call
type meshAPILatestLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPILatestLayerCall) Return(arg0 types.LayerID) *meshAPILatestLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPILatestLayerCall) Do(f func() types.LayerID) *meshAPILatestLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPILatestLayerCall) DoAndReturn(f func() types.LayerID) *meshAPILatestLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LatestLayerInState mocks base method.
func (m *MockmeshAPI) LatestLayerInState() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestLayerInState")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// LatestLayerInState indicates an expected call of LatestLayerInState.
func (mr *MockmeshAPIMockRecorder) LatestLayerInState() *meshAPILatestLayerInStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestLayerInState", reflect.TypeOf((*MockmeshAPI)(nil).LatestLayerInState))
	return &meshAPILatestLayerInStateCall{Call: call}
}

// meshAPILatestLayerInStateCall wrap *gomock.Call
type meshAPILatestLayerInStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPILatestLayerInStateCall) Return(arg0 types.LayerID) *meshAPILatestLayerInStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPILatestLayerInStateCall) Do(f func() types.LayerID) *meshAPILatestLayerInStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPILatestLayerInStateCall) DoAndReturn(f func() types.LayerID) *meshAPILatestLayerInStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MeshHash mocks base method.
func (m *MockmeshAPI) MeshHash(arg0 types.LayerID) (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MeshHash", arg0)
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MeshHash indicates an expected call of MeshHash.
func (mr *MockmeshAPIMockRecorder) MeshHash(arg0 any) *meshAPIMeshHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MeshHash", reflect.TypeOf((*MockmeshAPI)(nil).MeshHash), arg0)
	return &meshAPIMeshHashCall{Call: call}
}

// meshAPIMeshHashCall wrap *gomock.Call
type meshAPIMeshHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPIMeshHashCall) Return(arg0 types.Hash32, arg1 error) *meshAPIMeshHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPIMeshHashCall) Do(f func(types.LayerID) (types.Hash32, error)) *meshAPIMeshHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPIMeshHashCall) DoAndReturn(f func(types.LayerID) (types.Hash32, error)) *meshAPIMeshHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProcessedLayer mocks base method.
func (m *MockmeshAPI) ProcessedLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// ProcessedLayer indicates an expected call of ProcessedLayer.
func (mr *MockmeshAPIMockRecorder) ProcessedLayer() *meshAPIProcessedLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedLayer", reflect.TypeOf((*MockmeshAPI)(nil).ProcessedLayer))
	return &meshAPIProcessedLayerCall{Call: call}
}

// meshAPIProcessedLayerCall wrap *gomock.Call
type meshAPIProcessedLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *meshAPIProcessedLayerCall) Return(arg0 types.LayerID) *meshAPIProcessedLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *meshAPIProcessedLayerCall) Do(f func() types.LayerID) *meshAPIProcessedLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *meshAPIProcessedLayerCall) DoAndReturn(f func() types.LayerID) *meshAPIProcessedLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockoracle is a mock of oracle interface.
type Mockoracle struct {
	ctrl     *gomock.Controller
	recorder *MockoracleMockRecorder
}

// MockoracleMockRecorder is the mock recorder for Mockoracle.
type MockoracleMockRecorder struct {
	mock *Mockoracle
}

// NewMockoracle creates a new mock instance.
func NewMockoracle(ctrl *gomock.Controller) *Mockoracle {
	mock := &Mockoracle{ctrl: ctrl}
	mock.recorder = &MockoracleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockoracle) EXPECT() *MockoracleMockRecorder {
	return m.recorder
}

// ActiveSet mocks base method.
func (m *Mockoracle) ActiveSet(arg0 context.Context, arg1 types.EpochID) ([]types.ATXID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActiveSet", arg0, arg1)
	ret0, _ := ret[0].([]types.ATXID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ActiveSet indicates an expected call of ActiveSet.
func (mr *MockoracleMockRecorder) ActiveSet(arg0, arg1 any) *oracleActiveSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActiveSet", reflect.TypeOf((*Mockoracle)(nil).ActiveSet), arg0, arg1)
	return &oracleActiveSetCall{Call: call}
}

// oracleActiveSetCall wrap *gomock.Call
type oracleActiveSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *oracleActiveSetCall) Return(arg0 []types.ATXID, arg1 error) *oracleActiveSetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *oracleActiveSetCall) Do(f func(context.Context, types.EpochID) ([]types.ATXID, error)) *oracleActiveSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *oracleActiveSetCall) DoAndReturn(f func(context.Context, types.EpochID) ([]types.ATXID, error)) *oracleActiveSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
