// Code generated by MockGen. DO NOT EDIT.
// Source: ./interface.go
//
// Generated by this command:
//
//	mockgen -typed -package=grpcserver -destination=./mocks.go -source=./interface.go
//

// Package grpcserver is a generated GoMock package.
package grpcserver

import (
	context "context"
	reflect "reflect"
	time "time"

	network "github.com/libp2p/go-libp2p/core/network"
	multiaddr "github.com/multiformats/go-multiaddr"
	activation "github.com/spacemeshos/go-spacemesh/activation"
	types "github.com/spacemeshos/go-spacemesh/common/types"
	wire "github.com/spacemeshos/go-spacemesh/malfeasance/wire"
	p2p "github.com/spacemeshos/go-spacemesh/p2p"
	signing "github.com/spacemeshos/go-spacemesh/signing"
	system "github.com/spacemeshos/go-spacemesh/system"
	gomock "go.uber.org/mock/gomock"
)

// MocknetworkInfo is a mock of networkInfo interface.
type MocknetworkInfo struct {
	ctrl     *gomock.Controller
	recorder *MocknetworkInfoMockRecorder
}

// MocknetworkInfoMockRecorder is the mock recorder for MocknetworkInfo.
type MocknetworkInfoMockRecorder struct {
	mock *MocknetworkInfo
}

// NewMocknetworkInfo creates a new mock instance.
func NewMocknetworkInfo(ctrl *gomock.Controller) *MocknetworkInfo {
	mock := &MocknetworkInfo{ctrl: ctrl}
	mock.recorder = &MocknetworkInfoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocknetworkInfo) EXPECT() *MocknetworkInfoMockRecorder {
	return m.recorder
}

// DHTServerEnabled mocks base method.
func (m *MocknetworkInfo) DHTServerEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DHTServerEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// DHTServerEnabled indicates an expected call of DHTServerEnabled.
func (mr *MocknetworkInfoMockRecorder) DHTServerEnabled() *MocknetworkInfoDHTServerEnabledCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DHTServerEnabled", reflect.TypeOf((*MocknetworkInfo)(nil).DHTServerEnabled))
	return &MocknetworkInfoDHTServerEnabledCall{Call: call}
}

// MocknetworkInfoDHTServerEnabledCall wrap *gomock.Call
type MocknetworkInfoDHTServerEnabledCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoDHTServerEnabledCall) Return(arg0 bool) *MocknetworkInfoDHTServerEnabledCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoDHTServerEnabledCall) Do(f func() bool) *MocknetworkInfoDHTServerEnabledCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoDHTServerEnabledCall) DoAndReturn(f func() bool) *MocknetworkInfoDHTServerEnabledCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ID mocks base method.
func (m *MocknetworkInfo) ID() p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(p2p.Peer)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MocknetworkInfoMockRecorder) ID() *MocknetworkInfoIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MocknetworkInfo)(nil).ID))
	return &MocknetworkInfoIDCall{Call: call}
}

// MocknetworkInfoIDCall wrap *gomock.Call
type MocknetworkInfoIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoIDCall) Return(arg0 p2p.Peer) *MocknetworkInfoIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoIDCall) Do(f func() p2p.Peer) *MocknetworkInfoIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoIDCall) DoAndReturn(f func() p2p.Peer) *MocknetworkInfoIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// KnownAddresses mocks base method.
func (m *MocknetworkInfo) KnownAddresses() []multiaddr.Multiaddr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KnownAddresses")
	ret0, _ := ret[0].([]multiaddr.Multiaddr)
	return ret0
}

// KnownAddresses indicates an expected call of KnownAddresses.
func (mr *MocknetworkInfoMockRecorder) KnownAddresses() *MocknetworkInfoKnownAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KnownAddresses", reflect.TypeOf((*MocknetworkInfo)(nil).KnownAddresses))
	return &MocknetworkInfoKnownAddressesCall{Call: call}
}

// MocknetworkInfoKnownAddressesCall wrap *gomock.Call
type MocknetworkInfoKnownAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoKnownAddressesCall) Return(arg0 []multiaddr.Multiaddr) *MocknetworkInfoKnownAddressesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoKnownAddressesCall) Do(f func() []multiaddr.Multiaddr) *MocknetworkInfoKnownAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoKnownAddressesCall) DoAndReturn(f func() []multiaddr.Multiaddr) *MocknetworkInfoKnownAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListenAddresses mocks base method.
func (m *MocknetworkInfo) ListenAddresses() []multiaddr.Multiaddr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListenAddresses")
	ret0, _ := ret[0].([]multiaddr.Multiaddr)
	return ret0
}

// ListenAddresses indicates an expected call of ListenAddresses.
func (mr *MocknetworkInfoMockRecorder) ListenAddresses() *MocknetworkInfoListenAddressesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenAddresses", reflect.TypeOf((*MocknetworkInfo)(nil).ListenAddresses))
	return &MocknetworkInfoListenAddressesCall{Call: call}
}

// MocknetworkInfoListenAddressesCall wrap *gomock.Call
type MocknetworkInfoListenAddressesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoListenAddressesCall) Return(arg0 []multiaddr.Multiaddr) *MocknetworkInfoListenAddressesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoListenAddressesCall) Do(f func() []multiaddr.Multiaddr) *MocknetworkInfoListenAddressesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoListenAddressesCall) DoAndReturn(f func() []multiaddr.Multiaddr) *MocknetworkInfoListenAddressesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NATDeviceType mocks base method.
func (m *MocknetworkInfo) NATDeviceType() (network.NATDeviceType, network.NATDeviceType) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NATDeviceType")
	ret0, _ := ret[0].(network.NATDeviceType)
	ret1, _ := ret[1].(network.NATDeviceType)
	return ret0, ret1
}

// NATDeviceType indicates an expected call of NATDeviceType.
func (mr *MocknetworkInfoMockRecorder) NATDeviceType() *MocknetworkInfoNATDeviceTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NATDeviceType", reflect.TypeOf((*MocknetworkInfo)(nil).NATDeviceType))
	return &MocknetworkInfoNATDeviceTypeCall{Call: call}
}

// MocknetworkInfoNATDeviceTypeCall wrap *gomock.Call
type MocknetworkInfoNATDeviceTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoNATDeviceTypeCall) Return(udpNATType, tcpNATType network.NATDeviceType) *MocknetworkInfoNATDeviceTypeCall {
	c.Call = c.Call.Return(udpNATType, tcpNATType)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoNATDeviceTypeCall) Do(f func() (network.NATDeviceType, network.NATDeviceType)) *MocknetworkInfoNATDeviceTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoNATDeviceTypeCall) DoAndReturn(f func() (network.NATDeviceType, network.NATDeviceType)) *MocknetworkInfoNATDeviceTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Reachability mocks base method.
func (m *MocknetworkInfo) Reachability() network.Reachability {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reachability")
	ret0, _ := ret[0].(network.Reachability)
	return ret0
}

// Reachability indicates an expected call of Reachability.
func (mr *MocknetworkInfoMockRecorder) Reachability() *MocknetworkInfoReachabilityCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reachability", reflect.TypeOf((*MocknetworkInfo)(nil).Reachability))
	return &MocknetworkInfoReachabilityCall{Call: call}
}

// MocknetworkInfoReachabilityCall wrap *gomock.Call
type MocknetworkInfoReachabilityCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocknetworkInfoReachabilityCall) Return(arg0 network.Reachability) *MocknetworkInfoReachabilityCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocknetworkInfoReachabilityCall) Do(f func() network.Reachability) *MocknetworkInfoReachabilityCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocknetworkInfoReachabilityCall) DoAndReturn(f func() network.Reachability) *MocknetworkInfoReachabilityCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockconservativeState is a mock of conservativeState interface.
type MockconservativeState struct {
	ctrl     *gomock.Controller
	recorder *MockconservativeStateMockRecorder
}

// MockconservativeStateMockRecorder is the mock recorder for MockconservativeState.
type MockconservativeStateMockRecorder struct {
	mock *MockconservativeState
}

// NewMockconservativeState creates a new mock instance.
func NewMockconservativeState(ctrl *gomock.Controller) *MockconservativeState {
	mock := &MockconservativeState{ctrl: ctrl}
	mock.recorder = &MockconservativeStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockconservativeState) EXPECT() *MockconservativeStateMockRecorder {
	return m.recorder
}

// GetAllAccounts mocks base method.
func (m *MockconservativeState) GetAllAccounts() ([]*types.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllAccounts")
	ret0, _ := ret[0].([]*types.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllAccounts indicates an expected call of GetAllAccounts.
func (mr *MockconservativeStateMockRecorder) GetAllAccounts() *MockconservativeStateGetAllAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllAccounts", reflect.TypeOf((*MockconservativeState)(nil).GetAllAccounts))
	return &MockconservativeStateGetAllAccountsCall{Call: call}
}

// MockconservativeStateGetAllAccountsCall wrap *gomock.Call
type MockconservativeStateGetAllAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetAllAccountsCall) Return(arg0 []*types.Account, arg1 error) *MockconservativeStateGetAllAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetAllAccountsCall) Do(f func() ([]*types.Account, error)) *MockconservativeStateGetAllAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetAllAccountsCall) DoAndReturn(f func() ([]*types.Account, error)) *MockconservativeStateGetAllAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockconservativeState) GetBalance(arg0 types.Address) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockconservativeStateMockRecorder) GetBalance(arg0 any) *MockconservativeStateGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockconservativeState)(nil).GetBalance), arg0)
	return &MockconservativeStateGetBalanceCall{Call: call}
}

// MockconservativeStateGetBalanceCall wrap *gomock.Call
type MockconservativeStateGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetBalanceCall) Return(arg0 uint64, arg1 error) *MockconservativeStateGetBalanceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetBalanceCall) Do(f func(types.Address) (uint64, error)) *MockconservativeStateGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetBalanceCall) DoAndReturn(f func(types.Address) (uint64, error)) *MockconservativeStateGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLayerStateRoot mocks base method.
func (m *MockconservativeState) GetLayerStateRoot(arg0 types.LayerID) (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayerStateRoot", arg0)
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayerStateRoot indicates an expected call of GetLayerStateRoot.
func (mr *MockconservativeStateMockRecorder) GetLayerStateRoot(arg0 any) *MockconservativeStateGetLayerStateRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayerStateRoot", reflect.TypeOf((*MockconservativeState)(nil).GetLayerStateRoot), arg0)
	return &MockconservativeStateGetLayerStateRootCall{Call: call}
}

// MockconservativeStateGetLayerStateRootCall wrap *gomock.Call
type MockconservativeStateGetLayerStateRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetLayerStateRootCall) Return(arg0 types.Hash32, arg1 error) *MockconservativeStateGetLayerStateRootCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetLayerStateRootCall) Do(f func(types.LayerID) (types.Hash32, error)) *MockconservativeStateGetLayerStateRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetLayerStateRootCall) DoAndReturn(f func(types.LayerID) (types.Hash32, error)) *MockconservativeStateGetLayerStateRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeshTransaction mocks base method.
func (m *MockconservativeState) GetMeshTransaction(arg0 types.TransactionID) (*types.MeshTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeshTransaction", arg0)
	ret0, _ := ret[0].(*types.MeshTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMeshTransaction indicates an expected call of GetMeshTransaction.
func (mr *MockconservativeStateMockRecorder) GetMeshTransaction(arg0 any) *MockconservativeStateGetMeshTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeshTransaction", reflect.TypeOf((*MockconservativeState)(nil).GetMeshTransaction), arg0)
	return &MockconservativeStateGetMeshTransactionCall{Call: call}
}

// MockconservativeStateGetMeshTransactionCall wrap *gomock.Call
type MockconservativeStateGetMeshTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetMeshTransactionCall) Return(arg0 *types.MeshTransaction, arg1 error) *MockconservativeStateGetMeshTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetMeshTransactionCall) Do(f func(types.TransactionID) (*types.MeshTransaction, error)) *MockconservativeStateGetMeshTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetMeshTransactionCall) DoAndReturn(f func(types.TransactionID) (*types.MeshTransaction, error)) *MockconservativeStateGetMeshTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeshTransactions mocks base method.
func (m *MockconservativeState) GetMeshTransactions(arg0 []types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{}) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeshTransactions", arg0)
	ret0, _ := ret[0].([]*types.MeshTransaction)
	ret1, _ := ret[1].(map[types.TransactionID]struct{})
	return ret0, ret1
}

// GetMeshTransactions indicates an expected call of GetMeshTransactions.
func (mr *MockconservativeStateMockRecorder) GetMeshTransactions(arg0 any) *MockconservativeStateGetMeshTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeshTransactions", reflect.TypeOf((*MockconservativeState)(nil).GetMeshTransactions), arg0)
	return &MockconservativeStateGetMeshTransactionsCall{Call: call}
}

// MockconservativeStateGetMeshTransactionsCall wrap *gomock.Call
type MockconservativeStateGetMeshTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetMeshTransactionsCall) Return(arg0 []*types.MeshTransaction, arg1 map[types.TransactionID]struct{}) *MockconservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetMeshTransactionsCall) Do(f func([]types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{})) *MockconservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetMeshTransactionsCall) DoAndReturn(f func([]types.TransactionID) ([]*types.MeshTransaction, map[types.TransactionID]struct{})) *MockconservativeStateGetMeshTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockconservativeState) GetNonce(arg0 types.Address) (types.Nonce, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(types.Nonce)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockconservativeStateMockRecorder) GetNonce(arg0 any) *MockconservativeStateGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockconservativeState)(nil).GetNonce), arg0)
	return &MockconservativeStateGetNonceCall{Call: call}
}

// MockconservativeStateGetNonceCall wrap *gomock.Call
type MockconservativeStateGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetNonceCall) Return(arg0 types.Nonce, arg1 error) *MockconservativeStateGetNonceCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetNonceCall) Do(f func(types.Address) (types.Nonce, error)) *MockconservativeStateGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetNonceCall) DoAndReturn(f func(types.Address) (types.Nonce, error)) *MockconservativeStateGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetProjection mocks base method.
func (m *MockconservativeState) GetProjection(arg0 types.Address) (uint64, uint64) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProjection", arg0)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	return ret0, ret1
}

// GetProjection indicates an expected call of GetProjection.
func (mr *MockconservativeStateMockRecorder) GetProjection(arg0 any) *MockconservativeStateGetProjectionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjection", reflect.TypeOf((*MockconservativeState)(nil).GetProjection), arg0)
	return &MockconservativeStateGetProjectionCall{Call: call}
}

// MockconservativeStateGetProjectionCall wrap *gomock.Call
type MockconservativeStateGetProjectionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetProjectionCall) Return(arg0, arg1 uint64) *MockconservativeStateGetProjectionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetProjectionCall) Do(f func(types.Address) (uint64, uint64)) *MockconservativeStateGetProjectionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetProjectionCall) DoAndReturn(f func(types.Address) (uint64, uint64)) *MockconservativeStateGetProjectionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStateRoot mocks base method.
func (m *MockconservativeState) GetStateRoot() (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStateRoot")
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStateRoot indicates an expected call of GetStateRoot.
func (mr *MockconservativeStateMockRecorder) GetStateRoot() *MockconservativeStateGetStateRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStateRoot", reflect.TypeOf((*MockconservativeState)(nil).GetStateRoot))
	return &MockconservativeStateGetStateRootCall{Call: call}
}

// MockconservativeStateGetStateRootCall wrap *gomock.Call
type MockconservativeStateGetStateRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetStateRootCall) Return(arg0 types.Hash32, arg1 error) *MockconservativeStateGetStateRootCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetStateRootCall) Do(f func() (types.Hash32, error)) *MockconservativeStateGetStateRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetStateRootCall) DoAndReturn(f func() (types.Hash32, error)) *MockconservativeStateGetStateRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionsByAddress mocks base method.
func (m *MockconservativeState) GetTransactionsByAddress(arg0, arg1 types.LayerID, arg2 types.Address) ([]*types.MeshTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionsByAddress", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*types.MeshTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionsByAddress indicates an expected call of GetTransactionsByAddress.
func (mr *MockconservativeStateMockRecorder) GetTransactionsByAddress(arg0, arg1, arg2 any) *MockconservativeStateGetTransactionsByAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionsByAddress", reflect.TypeOf((*MockconservativeState)(nil).GetTransactionsByAddress), arg0, arg1, arg2)
	return &MockconservativeStateGetTransactionsByAddressCall{Call: call}
}

// MockconservativeStateGetTransactionsByAddressCall wrap *gomock.Call
type MockconservativeStateGetTransactionsByAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateGetTransactionsByAddressCall) Return(arg0 []*types.MeshTransaction, arg1 error) *MockconservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateGetTransactionsByAddressCall) Do(f func(types.LayerID, types.LayerID, types.Address) ([]*types.MeshTransaction, error)) *MockconservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateGetTransactionsByAddressCall) DoAndReturn(f func(types.LayerID, types.LayerID, types.Address) ([]*types.MeshTransaction, error)) *MockconservativeStateGetTransactionsByAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Validation mocks base method.
func (m *MockconservativeState) Validation(raw types.RawTx) system.ValidationRequest {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validation", raw)
	ret0, _ := ret[0].(system.ValidationRequest)
	return ret0
}

// Validation indicates an expected call of Validation.
func (mr *MockconservativeStateMockRecorder) Validation(raw any) *MockconservativeStateValidationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validation", reflect.TypeOf((*MockconservativeState)(nil).Validation), raw)
	return &MockconservativeStateValidationCall{Call: call}
}

// MockconservativeStateValidationCall wrap *gomock.Call
type MockconservativeStateValidationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockconservativeStateValidationCall) Return(arg0 system.ValidationRequest) *MockconservativeStateValidationCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockconservativeStateValidationCall) Do(f func(types.RawTx) system.ValidationRequest) *MockconservativeStateValidationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockconservativeStateValidationCall) DoAndReturn(f func(types.RawTx) system.ValidationRequest) *MockconservativeStateValidationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mocksyncer is a mock of syncer interface.
type Mocksyncer struct {
	ctrl     *gomock.Controller
	recorder *MocksyncerMockRecorder
}

// MocksyncerMockRecorder is the mock recorder for Mocksyncer.
type MocksyncerMockRecorder struct {
	mock *Mocksyncer
}

// NewMocksyncer creates a new mock instance.
func NewMocksyncer(ctrl *gomock.Controller) *Mocksyncer {
	mock := &Mocksyncer{ctrl: ctrl}
	mock.recorder = &MocksyncerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocksyncer) EXPECT() *MocksyncerMockRecorder {
	return m.recorder
}

// IsSynced mocks base method.
func (m *Mocksyncer) IsSynced(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSynced", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSynced indicates an expected call of IsSynced.
func (mr *MocksyncerMockRecorder) IsSynced(arg0 any) *MocksyncerIsSyncedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSynced", reflect.TypeOf((*Mocksyncer)(nil).IsSynced), arg0)
	return &MocksyncerIsSyncedCall{Call: call}
}

// MocksyncerIsSyncedCall wrap *gomock.Call
type MocksyncerIsSyncedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocksyncerIsSyncedCall) Return(arg0 bool) *MocksyncerIsSyncedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocksyncerIsSyncedCall) Do(f func(context.Context) bool) *MocksyncerIsSyncedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocksyncerIsSyncedCall) DoAndReturn(f func(context.Context) bool) *MocksyncerIsSyncedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxValidator is a mock of txValidator interface.
type MocktxValidator struct {
	ctrl     *gomock.Controller
	recorder *MocktxValidatorMockRecorder
}

// MocktxValidatorMockRecorder is the mock recorder for MocktxValidator.
type MocktxValidatorMockRecorder struct {
	mock *MocktxValidator
}

// NewMocktxValidator creates a new mock instance.
func NewMocktxValidator(ctrl *gomock.Controller) *MocktxValidator {
	mock := &MocktxValidator{ctrl: ctrl}
	mock.recorder = &MocktxValidatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxValidator) EXPECT() *MocktxValidatorMockRecorder {
	return m.recorder
}

// VerifyAndCacheTx mocks base method.
func (m *MocktxValidator) VerifyAndCacheTx(arg0 context.Context, arg1 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyAndCacheTx", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyAndCacheTx indicates an expected call of VerifyAndCacheTx.
func (mr *MocktxValidatorMockRecorder) VerifyAndCacheTx(arg0, arg1 any) *MocktxValidatorVerifyAndCacheTxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyAndCacheTx", reflect.TypeOf((*MocktxValidator)(nil).VerifyAndCacheTx), arg0, arg1)
	return &MocktxValidatorVerifyAndCacheTxCall{Call: call}
}

// MocktxValidatorVerifyAndCacheTxCall wrap *gomock.Call
type MocktxValidatorVerifyAndCacheTxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxValidatorVerifyAndCacheTxCall) Return(arg0 error) *MocktxValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxValidatorVerifyAndCacheTxCall) Do(f func(context.Context, []byte) error) *MocktxValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxValidatorVerifyAndCacheTxCall) DoAndReturn(f func(context.Context, []byte) error) *MocktxValidatorVerifyAndCacheTxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockatxProvider is a mock of atxProvider interface.
type MockatxProvider struct {
	ctrl     *gomock.Controller
	recorder *MockatxProviderMockRecorder
}

// MockatxProviderMockRecorder is the mock recorder for MockatxProvider.
type MockatxProviderMockRecorder struct {
	mock *MockatxProvider
}

// NewMockatxProvider creates a new mock instance.
func NewMockatxProvider(ctrl *gomock.Controller) *MockatxProvider {
	mock := &MockatxProvider{ctrl: ctrl}
	mock.recorder = &MockatxProviderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockatxProvider) EXPECT() *MockatxProviderMockRecorder {
	return m.recorder
}

// GetAtx mocks base method.
func (m *MockatxProvider) GetAtx(id types.ATXID) (*types.ActivationTx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAtx", id)
	ret0, _ := ret[0].(*types.ActivationTx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAtx indicates an expected call of GetAtx.
func (mr *MockatxProviderMockRecorder) GetAtx(id any) *MockatxProviderGetAtxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAtx", reflect.TypeOf((*MockatxProvider)(nil).GetAtx), id)
	return &MockatxProviderGetAtxCall{Call: call}
}

// MockatxProviderGetAtxCall wrap *gomock.Call
type MockatxProviderGetAtxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockatxProviderGetAtxCall) Return(arg0 *types.ActivationTx, arg1 error) *MockatxProviderGetAtxCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockatxProviderGetAtxCall) Do(f func(types.ATXID) (*types.ActivationTx, error)) *MockatxProviderGetAtxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockatxProviderGetAtxCall) DoAndReturn(f func(types.ATXID) (*types.ActivationTx, error)) *MockatxProviderGetAtxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMalfeasanceProof mocks base method.
func (m *MockatxProvider) GetMalfeasanceProof(id types.NodeID) (*wire.MalfeasanceProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMalfeasanceProof", id)
	ret0, _ := ret[0].(*wire.MalfeasanceProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMalfeasanceProof indicates an expected call of GetMalfeasanceProof.
func (mr *MockatxProviderMockRecorder) GetMalfeasanceProof(id any) *MockatxProviderGetMalfeasanceProofCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMalfeasanceProof", reflect.TypeOf((*MockatxProvider)(nil).GetMalfeasanceProof), id)
	return &MockatxProviderGetMalfeasanceProofCall{Call: call}
}

// MockatxProviderGetMalfeasanceProofCall wrap *gomock.Call
type MockatxProviderGetMalfeasanceProofCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockatxProviderGetMalfeasanceProofCall) Return(arg0 *wire.MalfeasanceProof, arg1 error) *MockatxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockatxProviderGetMalfeasanceProofCall) Do(f func(types.NodeID) (*wire.MalfeasanceProof, error)) *MockatxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockatxProviderGetMalfeasanceProofCall) DoAndReturn(f func(types.NodeID) (*wire.MalfeasanceProof, error)) *MockatxProviderGetMalfeasanceProofCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MaxHeightAtx mocks base method.
func (m *MockatxProvider) MaxHeightAtx() (types.ATXID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MaxHeightAtx")
	ret0, _ := ret[0].(types.ATXID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MaxHeightAtx indicates an expected call of MaxHeightAtx.
func (mr *MockatxProviderMockRecorder) MaxHeightAtx() *MockatxProviderMaxHeightAtxCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MaxHeightAtx", reflect.TypeOf((*MockatxProvider)(nil).MaxHeightAtx))
	return &MockatxProviderMaxHeightAtxCall{Call: call}
}

// MockatxProviderMaxHeightAtxCall wrap *gomock.Call
type MockatxProviderMaxHeightAtxCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockatxProviderMaxHeightAtxCall) Return(arg0 types.ATXID, arg1 error) *MockatxProviderMaxHeightAtxCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockatxProviderMaxHeightAtxCall) Do(f func() (types.ATXID, error)) *MockatxProviderMaxHeightAtxCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockatxProviderMaxHeightAtxCall) DoAndReturn(f func() (types.ATXID, error)) *MockatxProviderMaxHeightAtxCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpostState is a mock of postState interface.
type MockpostState struct {
	ctrl     *gomock.Controller
	recorder *MockpostStateMockRecorder
}

// MockpostStateMockRecorder is the mock recorder for MockpostState.
type MockpostStateMockRecorder struct {
	mock *MockpostState
}

// NewMockpostState creates a new mock instance.
func NewMockpostState(ctrl *gomock.Controller) *MockpostState {
	mock := &MockpostState{ctrl: ctrl}
	mock.recorder = &MockpostStateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpostState) EXPECT() *MockpostStateMockRecorder {
	return m.recorder
}

// PostStates mocks base method.
func (m *MockpostState) PostStates() map[types.IdentityDescriptor]types.PostState {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostStates")
	ret0, _ := ret[0].(map[types.IdentityDescriptor]types.PostState)
	return ret0
}

// PostStates indicates an expected call of PostStates.
func (mr *MockpostStateMockRecorder) PostStates() *MockpostStatePostStatesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostStates", reflect.TypeOf((*MockpostState)(nil).PostStates))
	return &MockpostStatePostStatesCall{Call: call}
}

// MockpostStatePostStatesCall wrap *gomock.Call
type MockpostStatePostStatesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostStatePostStatesCall) Return(arg0 map[types.IdentityDescriptor]types.PostState) *MockpostStatePostStatesCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostStatePostStatesCall) Do(f func() map[types.IdentityDescriptor]types.PostState) *MockpostStatePostStatesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostStatePostStatesCall) DoAndReturn(f func() map[types.IdentityDescriptor]types.PostState) *MockpostStatePostStatesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpostSupervisor is a mock of postSupervisor interface.
type MockpostSupervisor struct {
	ctrl     *gomock.Controller
	recorder *MockpostSupervisorMockRecorder
}

// MockpostSupervisorMockRecorder is the mock recorder for MockpostSupervisor.
type MockpostSupervisorMockRecorder struct {
	mock *MockpostSupervisor
}

// NewMockpostSupervisor creates a new mock instance.
func NewMockpostSupervisor(ctrl *gomock.Controller) *MockpostSupervisor {
	mock := &MockpostSupervisor{ctrl: ctrl}
	mock.recorder = &MockpostSupervisorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpostSupervisor) EXPECT() *MockpostSupervisorMockRecorder {
	return m.recorder
}

// Benchmark mocks base method.
func (m *MockpostSupervisor) Benchmark(p activation.PostSetupProvider) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Benchmark", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Benchmark indicates an expected call of Benchmark.
func (mr *MockpostSupervisorMockRecorder) Benchmark(p any) *MockpostSupervisorBenchmarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Benchmark", reflect.TypeOf((*MockpostSupervisor)(nil).Benchmark), p)
	return &MockpostSupervisorBenchmarkCall{Call: call}
}

// MockpostSupervisorBenchmarkCall wrap *gomock.Call
type MockpostSupervisorBenchmarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorBenchmarkCall) Return(arg0 int, arg1 error) *MockpostSupervisorBenchmarkCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorBenchmarkCall) Do(f func(activation.PostSetupProvider) (int, error)) *MockpostSupervisorBenchmarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorBenchmarkCall) DoAndReturn(f func(activation.PostSetupProvider) (int, error)) *MockpostSupervisorBenchmarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Config mocks base method.
func (m *MockpostSupervisor) Config() activation.PostConfig {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Config")
	ret0, _ := ret[0].(activation.PostConfig)
	return ret0
}

// Config indicates an expected call of Config.
func (mr *MockpostSupervisorMockRecorder) Config() *MockpostSupervisorConfigCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Config", reflect.TypeOf((*MockpostSupervisor)(nil).Config))
	return &MockpostSupervisorConfigCall{Call: call}
}

// MockpostSupervisorConfigCall wrap *gomock.Call
type MockpostSupervisorConfigCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorConfigCall) Return(arg0 activation.PostConfig) *MockpostSupervisorConfigCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorConfigCall) Do(f func() activation.PostConfig) *MockpostSupervisorConfigCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorConfigCall) DoAndReturn(f func() activation.PostConfig) *MockpostSupervisorConfigCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Providers mocks base method.
func (m *MockpostSupervisor) Providers() ([]activation.PostSetupProvider, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Providers")
	ret0, _ := ret[0].([]activation.PostSetupProvider)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Providers indicates an expected call of Providers.
func (mr *MockpostSupervisorMockRecorder) Providers() *MockpostSupervisorProvidersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Providers", reflect.TypeOf((*MockpostSupervisor)(nil).Providers))
	return &MockpostSupervisorProvidersCall{Call: call}
}

// MockpostSupervisorProvidersCall wrap *gomock.Call
type MockpostSupervisorProvidersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorProvidersCall) Return(arg0 []activation.PostSetupProvider, arg1 error) *MockpostSupervisorProvidersCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorProvidersCall) Do(f func() ([]activation.PostSetupProvider, error)) *MockpostSupervisorProvidersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorProvidersCall) DoAndReturn(f func() ([]activation.PostSetupProvider, error)) *MockpostSupervisorProvidersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockpostSupervisor) Start(cmdCfg activation.PostSupervisorConfig, opts activation.PostSetupOpts, sig *signing.EdSigner) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", cmdCfg, opts, sig)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockpostSupervisorMockRecorder) Start(cmdCfg, opts, sig any) *MockpostSupervisorStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockpostSupervisor)(nil).Start), cmdCfg, opts, sig)
	return &MockpostSupervisorStartCall{Call: call}
}

// MockpostSupervisorStartCall wrap *gomock.Call
type MockpostSupervisorStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorStartCall) Return(arg0 error) *MockpostSupervisorStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorStartCall) Do(f func(activation.PostSupervisorConfig, activation.PostSetupOpts, *signing.EdSigner) error) *MockpostSupervisorStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorStartCall) DoAndReturn(f func(activation.PostSupervisorConfig, activation.PostSetupOpts, *signing.EdSigner) error) *MockpostSupervisorStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockpostSupervisor) Status() *activation.PostSetupStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(*activation.PostSetupStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockpostSupervisorMockRecorder) Status() *MockpostSupervisorStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockpostSupervisor)(nil).Status))
	return &MockpostSupervisorStatusCall{Call: call}
}

// MockpostSupervisorStatusCall wrap *gomock.Call
type MockpostSupervisorStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorStatusCall) Return(arg0 *activation.PostSetupStatus) *MockpostSupervisorStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorStatusCall) Do(f func() *activation.PostSetupStatus) *MockpostSupervisorStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorStatusCall) DoAndReturn(f func() *activation.PostSetupStatus) *MockpostSupervisorStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockpostSupervisor) Stop(deleteFiles bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", deleteFiles)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockpostSupervisorMockRecorder) Stop(deleteFiles any) *MockpostSupervisorStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockpostSupervisor)(nil).Stop), deleteFiles)
	return &MockpostSupervisorStopCall{Call: call}
}

// MockpostSupervisorStopCall wrap *gomock.Call
type MockpostSupervisorStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpostSupervisorStopCall) Return(arg0 error) *MockpostSupervisorStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpostSupervisorStopCall) Do(f func(bool) error) *MockpostSupervisorStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpostSupervisorStopCall) DoAndReturn(f func(bool) error) *MockpostSupervisorStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockgrpcPostService is a mock of grpcPostService interface.
type MockgrpcPostService struct {
	ctrl     *gomock.Controller
	recorder *MockgrpcPostServiceMockRecorder
}

// MockgrpcPostServiceMockRecorder is the mock recorder for MockgrpcPostService.
type MockgrpcPostServiceMockRecorder struct {
	mock *MockgrpcPostService
}

// NewMockgrpcPostService creates a new mock instance.
func NewMockgrpcPostService(ctrl *gomock.Controller) *MockgrpcPostService {
	mock := &MockgrpcPostService{ctrl: ctrl}
	mock.recorder = &MockgrpcPostServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgrpcPostService) EXPECT() *MockgrpcPostServiceMockRecorder {
	return m.recorder
}

// AllowConnections mocks base method.
func (m *MockgrpcPostService) AllowConnections(allow bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AllowConnections", allow)
}

// AllowConnections indicates an expected call of AllowConnections.
func (mr *MockgrpcPostServiceMockRecorder) AllowConnections(allow any) *MockgrpcPostServiceAllowConnectionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllowConnections", reflect.TypeOf((*MockgrpcPostService)(nil).AllowConnections), allow)
	return &MockgrpcPostServiceAllowConnectionsCall{Call: call}
}

// MockgrpcPostServiceAllowConnectionsCall wrap *gomock.Call
type MockgrpcPostServiceAllowConnectionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockgrpcPostServiceAllowConnectionsCall) Return() *MockgrpcPostServiceAllowConnectionsCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockgrpcPostServiceAllowConnectionsCall) Do(f func(bool)) *MockgrpcPostServiceAllowConnectionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockgrpcPostServiceAllowConnectionsCall) DoAndReturn(f func(bool)) *MockgrpcPostServiceAllowConnectionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockpeerCounter is a mock of peerCounter interface.
type MockpeerCounter struct {
	ctrl     *gomock.Controller
	recorder *MockpeerCounterMockRecorder
}

// MockpeerCounterMockRecorder is the mock recorder for MockpeerCounter.
type MockpeerCounterMockRecorder struct {
	mock *MockpeerCounter
}

// NewMockpeerCounter creates a new mock instance.
func NewMockpeerCounter(ctrl *gomock.Controller) *MockpeerCounter {
	mock := &MockpeerCounter{ctrl: ctrl}
	mock.recorder = &MockpeerCounterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpeerCounter) EXPECT() *MockpeerCounterMockRecorder {
	return m.recorder
}

// PeerCount mocks base method.
func (m *MockpeerCounter) PeerCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeerCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// PeerCount indicates an expected call of PeerCount.
func (mr *MockpeerCounterMockRecorder) PeerCount() *MockpeerCounterPeerCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeerCount", reflect.TypeOf((*MockpeerCounter)(nil).PeerCount))
	return &MockpeerCounterPeerCountCall{Call: call}
}

// MockpeerCounterPeerCountCall wrap *gomock.Call
type MockpeerCounterPeerCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeerCounterPeerCountCall) Return(arg0 uint64) *MockpeerCounterPeerCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeerCounterPeerCountCall) Do(f func() uint64) *MockpeerCounterPeerCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeerCounterPeerCountCall) DoAndReturn(f func() uint64) *MockpeerCounterPeerCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockpeers is a mock of peers interface.
type Mockpeers struct {
	ctrl     *gomock.Controller
	recorder *MockpeersMockRecorder
}

// MockpeersMockRecorder is the mock recorder for Mockpeers.
type MockpeersMockRecorder struct {
	mock *Mockpeers
}

// NewMockpeers creates a new mock instance.
func NewMockpeers(ctrl *gomock.Controller) *Mockpeers {
	mock := &Mockpeers{ctrl: ctrl}
	mock.recorder = &MockpeersMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockpeers) EXPECT() *MockpeersMockRecorder {
	return m.recorder
}

// ConnectedPeerInfo mocks base method.
func (m *Mockpeers) ConnectedPeerInfo(arg0 p2p.Peer) *p2p.PeerInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConnectedPeerInfo", arg0)
	ret0, _ := ret[0].(*p2p.PeerInfo)
	return ret0
}

// ConnectedPeerInfo indicates an expected call of ConnectedPeerInfo.
func (mr *MockpeersMockRecorder) ConnectedPeerInfo(arg0 any) *MockpeersConnectedPeerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConnectedPeerInfo", reflect.TypeOf((*Mockpeers)(nil).ConnectedPeerInfo), arg0)
	return &MockpeersConnectedPeerInfoCall{Call: call}
}

// MockpeersConnectedPeerInfoCall wrap *gomock.Call
type MockpeersConnectedPeerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeersConnectedPeerInfoCall) Return(arg0 *p2p.PeerInfo) *MockpeersConnectedPeerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeersConnectedPeerInfoCall) Do(f func(p2p.Peer) *p2p.PeerInfo) *MockpeersConnectedPeerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeersConnectedPeerInfoCall) DoAndReturn(f func(p2p.Peer) *p2p.PeerInfo) *MockpeersConnectedPeerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPeers mocks base method.
func (m *Mockpeers) GetPeers() []p2p.Peer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPeers")
	ret0, _ := ret[0].([]p2p.Peer)
	return ret0
}

// GetPeers indicates an expected call of GetPeers.
func (mr *MockpeersMockRecorder) GetPeers() *MockpeersGetPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPeers", reflect.TypeOf((*Mockpeers)(nil).GetPeers))
	return &MockpeersGetPeersCall{Call: call}
}

// MockpeersGetPeersCall wrap *gomock.Call
type MockpeersGetPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpeersGetPeersCall) Return(arg0 []p2p.Peer) *MockpeersGetPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpeersGetPeersCall) Do(f func() []p2p.Peer) *MockpeersGetPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpeersGetPeersCall) DoAndReturn(f func() []p2p.Peer) *MockpeersGetPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockgenesisTimeAPI is a mock of genesisTimeAPI interface.
type MockgenesisTimeAPI struct {
	ctrl     *gomock.Controller
	recorder *MockgenesisTimeAPIMockRecorder
}

// MockgenesisTimeAPIMockRecorder is the mock recorder for MockgenesisTimeAPI.
type MockgenesisTimeAPIMockRecorder struct {
	mock *MockgenesisTimeAPI
}

// NewMockgenesisTimeAPI creates a new mock instance.
func NewMockgenesisTimeAPI(ctrl *gomock.Controller) *MockgenesisTimeAPI {
	mock := &MockgenesisTimeAPI{ctrl: ctrl}
	mock.recorder = &MockgenesisTimeAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgenesisTimeAPI) EXPECT() *MockgenesisTimeAPIMockRecorder {
	return m.recorder
}

// CurrentLayer mocks base method.
func (m *MockgenesisTimeAPI) CurrentLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// CurrentLayer indicates an expected call of CurrentLayer.
func (mr *MockgenesisTimeAPIMockRecorder) CurrentLayer() *MockgenesisTimeAPICurrentLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentLayer", reflect.TypeOf((*MockgenesisTimeAPI)(nil).CurrentLayer))
	return &MockgenesisTimeAPICurrentLayerCall{Call: call}
}

// MockgenesisTimeAPICurrentLayerCall wrap *gomock.Call
type MockgenesisTimeAPICurrentLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockgenesisTimeAPICurrentLayerCall) Return(arg0 types.LayerID) *MockgenesisTimeAPICurrentLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockgenesisTimeAPICurrentLayerCall) Do(f func() types.LayerID) *MockgenesisTimeAPICurrentLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockgenesisTimeAPICurrentLayerCall) DoAndReturn(f func() types.LayerID) *MockgenesisTimeAPICurrentLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenesisTime mocks base method.
func (m *MockgenesisTimeAPI) GenesisTime() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenesisTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// GenesisTime indicates an expected call of GenesisTime.
func (mr *MockgenesisTimeAPIMockRecorder) GenesisTime() *MockgenesisTimeAPIGenesisTimeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenesisTime", reflect.TypeOf((*MockgenesisTimeAPI)(nil).GenesisTime))
	return &MockgenesisTimeAPIGenesisTimeCall{Call: call}
}

// MockgenesisTimeAPIGenesisTimeCall wrap *gomock.Call
type MockgenesisTimeAPIGenesisTimeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockgenesisTimeAPIGenesisTimeCall) Return(arg0 time.Time) *MockgenesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockgenesisTimeAPIGenesisTimeCall) Do(f func() time.Time) *MockgenesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockgenesisTimeAPIGenesisTimeCall) DoAndReturn(f func() time.Time) *MockgenesisTimeAPIGenesisTimeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockmeshAPI is a mock of meshAPI interface.
type MockmeshAPI struct {
	ctrl     *gomock.Controller
	recorder *MockmeshAPIMockRecorder
}

// MockmeshAPIMockRecorder is the mock recorder for MockmeshAPI.
type MockmeshAPIMockRecorder struct {
	mock *MockmeshAPI
}

// NewMockmeshAPI creates a new mock instance.
func NewMockmeshAPI(ctrl *gomock.Controller) *MockmeshAPI {
	mock := &MockmeshAPI{ctrl: ctrl}
	mock.recorder = &MockmeshAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmeshAPI) EXPECT() *MockmeshAPIMockRecorder {
	return m.recorder
}

// GetLayer mocks base method.
func (m *MockmeshAPI) GetLayer(arg0 types.LayerID) (*types.Layer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayer", arg0)
	ret0, _ := ret[0].(*types.Layer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayer indicates an expected call of GetLayer.
func (mr *MockmeshAPIMockRecorder) GetLayer(arg0 any) *MockmeshAPIGetLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayer", reflect.TypeOf((*MockmeshAPI)(nil).GetLayer), arg0)
	return &MockmeshAPIGetLayerCall{Call: call}
}

// MockmeshAPIGetLayerCall wrap *gomock.Call
type MockmeshAPIGetLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIGetLayerCall) Return(arg0 *types.Layer, arg1 error) *MockmeshAPIGetLayerCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIGetLayerCall) Do(f func(types.LayerID) (*types.Layer, error)) *MockmeshAPIGetLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIGetLayerCall) DoAndReturn(f func(types.LayerID) (*types.Layer, error)) *MockmeshAPIGetLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLayerVerified mocks base method.
func (m *MockmeshAPI) GetLayerVerified(arg0 types.LayerID) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLayerVerified", arg0)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLayerVerified indicates an expected call of GetLayerVerified.
func (mr *MockmeshAPIMockRecorder) GetLayerVerified(arg0 any) *MockmeshAPIGetLayerVerifiedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLayerVerified", reflect.TypeOf((*MockmeshAPI)(nil).GetLayerVerified), arg0)
	return &MockmeshAPIGetLayerVerifiedCall{Call: call}
}

// MockmeshAPIGetLayerVerifiedCall wrap *gomock.Call
type MockmeshAPIGetLayerVerifiedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIGetLayerVerifiedCall) Return(arg0 *types.Block, arg1 error) *MockmeshAPIGetLayerVerifiedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIGetLayerVerifiedCall) Do(f func(types.LayerID) (*types.Block, error)) *MockmeshAPIGetLayerVerifiedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIGetLayerVerifiedCall) DoAndReturn(f func(types.LayerID) (*types.Block, error)) *MockmeshAPIGetLayerVerifiedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRewardsByCoinbase mocks base method.
func (m *MockmeshAPI) GetRewardsByCoinbase(arg0 types.Address) ([]*types.Reward, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRewardsByCoinbase", arg0)
	ret0, _ := ret[0].([]*types.Reward)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRewardsByCoinbase indicates an expected call of GetRewardsByCoinbase.
func (mr *MockmeshAPIMockRecorder) GetRewardsByCoinbase(arg0 any) *MockmeshAPIGetRewardsByCoinbaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRewardsByCoinbase", reflect.TypeOf((*MockmeshAPI)(nil).GetRewardsByCoinbase), arg0)
	return &MockmeshAPIGetRewardsByCoinbaseCall{Call: call}
}

// MockmeshAPIGetRewardsByCoinbaseCall wrap *gomock.Call
type MockmeshAPIGetRewardsByCoinbaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIGetRewardsByCoinbaseCall) Return(arg0 []*types.Reward, arg1 error) *MockmeshAPIGetRewardsByCoinbaseCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIGetRewardsByCoinbaseCall) Do(f func(types.Address) ([]*types.Reward, error)) *MockmeshAPIGetRewardsByCoinbaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIGetRewardsByCoinbaseCall) DoAndReturn(f func(types.Address) ([]*types.Reward, error)) *MockmeshAPIGetRewardsByCoinbaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRewardsBySmesherId mocks base method.
func (m *MockmeshAPI) GetRewardsBySmesherId(id types.NodeID) ([]*types.Reward, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRewardsBySmesherId", id)
	ret0, _ := ret[0].([]*types.Reward)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRewardsBySmesherId indicates an expected call of GetRewardsBySmesherId.
func (mr *MockmeshAPIMockRecorder) GetRewardsBySmesherId(id any) *MockmeshAPIGetRewardsBySmesherIdCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRewardsBySmesherId", reflect.TypeOf((*MockmeshAPI)(nil).GetRewardsBySmesherId), id)
	return &MockmeshAPIGetRewardsBySmesherIdCall{Call: call}
}

// MockmeshAPIGetRewardsBySmesherIdCall wrap *gomock.Call
type MockmeshAPIGetRewardsBySmesherIdCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIGetRewardsBySmesherIdCall) Return(arg0 []*types.Reward, arg1 error) *MockmeshAPIGetRewardsBySmesherIdCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIGetRewardsBySmesherIdCall) Do(f func(types.NodeID) ([]*types.Reward, error)) *MockmeshAPIGetRewardsBySmesherIdCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIGetRewardsBySmesherIdCall) DoAndReturn(f func(types.NodeID) ([]*types.Reward, error)) *MockmeshAPIGetRewardsBySmesherIdCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LatestLayer mocks base method.
func (m *MockmeshAPI) LatestLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// LatestLayer indicates an expected call of LatestLayer.
func (mr *MockmeshAPIMockRecorder) LatestLayer() *MockmeshAPILatestLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestLayer", reflect.TypeOf((*MockmeshAPI)(nil).LatestLayer))
	return &MockmeshAPILatestLayerCall{Call: call}
}

// MockmeshAPILatestLayerCall wrap *gomock.Call
type MockmeshAPILatestLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPILatestLayerCall) Return(arg0 types.LayerID) *MockmeshAPILatestLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPILatestLayerCall) Do(f func() types.LayerID) *MockmeshAPILatestLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPILatestLayerCall) DoAndReturn(f func() types.LayerID) *MockmeshAPILatestLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LatestLayerInState mocks base method.
func (m *MockmeshAPI) LatestLayerInState() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LatestLayerInState")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// LatestLayerInState indicates an expected call of LatestLayerInState.
func (mr *MockmeshAPIMockRecorder) LatestLayerInState() *MockmeshAPILatestLayerInStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LatestLayerInState", reflect.TypeOf((*MockmeshAPI)(nil).LatestLayerInState))
	return &MockmeshAPILatestLayerInStateCall{Call: call}
}

// MockmeshAPILatestLayerInStateCall wrap *gomock.Call
type MockmeshAPILatestLayerInStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPILatestLayerInStateCall) Return(arg0 types.LayerID) *MockmeshAPILatestLayerInStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPILatestLayerInStateCall) Do(f func() types.LayerID) *MockmeshAPILatestLayerInStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPILatestLayerInStateCall) DoAndReturn(f func() types.LayerID) *MockmeshAPILatestLayerInStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MeshHash mocks base method.
func (m *MockmeshAPI) MeshHash(arg0 types.LayerID) (types.Hash32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MeshHash", arg0)
	ret0, _ := ret[0].(types.Hash32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MeshHash indicates an expected call of MeshHash.
func (mr *MockmeshAPIMockRecorder) MeshHash(arg0 any) *MockmeshAPIMeshHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MeshHash", reflect.TypeOf((*MockmeshAPI)(nil).MeshHash), arg0)
	return &MockmeshAPIMeshHashCall{Call: call}
}

// MockmeshAPIMeshHashCall wrap *gomock.Call
type MockmeshAPIMeshHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIMeshHashCall) Return(arg0 types.Hash32, arg1 error) *MockmeshAPIMeshHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIMeshHashCall) Do(f func(types.LayerID) (types.Hash32, error)) *MockmeshAPIMeshHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIMeshHashCall) DoAndReturn(f func(types.LayerID) (types.Hash32, error)) *MockmeshAPIMeshHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ProcessedLayer mocks base method.
func (m *MockmeshAPI) ProcessedLayer() types.LayerID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProcessedLayer")
	ret0, _ := ret[0].(types.LayerID)
	return ret0
}

// ProcessedLayer indicates an expected call of ProcessedLayer.
func (mr *MockmeshAPIMockRecorder) ProcessedLayer() *MockmeshAPIProcessedLayerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProcessedLayer", reflect.TypeOf((*MockmeshAPI)(nil).ProcessedLayer))
	return &MockmeshAPIProcessedLayerCall{Call: call}
}

// MockmeshAPIProcessedLayerCall wrap *gomock.Call
type MockmeshAPIProcessedLayerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockmeshAPIProcessedLayerCall) Return(arg0 types.LayerID) *MockmeshAPIProcessedLayerCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockmeshAPIProcessedLayerCall) Do(f func() types.LayerID) *MockmeshAPIProcessedLayerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockmeshAPIProcessedLayerCall) DoAndReturn(f func() types.LayerID) *MockmeshAPIProcessedLayerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockoracle is a mock of oracle interface.
type Mockoracle struct {
	ctrl     *gomock.Controller
	recorder *MockoracleMockRecorder
}

// MockoracleMockRecorder is the mock recorder for Mockoracle.
type MockoracleMockRecorder struct {
	mock *Mockoracle
}

// NewMockoracle creates a new mock instance.
func NewMockoracle(ctrl *gomock.Controller) *Mockoracle {
	mock := &Mockoracle{ctrl: ctrl}
	mock.recorder = &MockoracleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockoracle) EXPECT() *MockoracleMockRecorder {
	return m.recorder
}

// ActiveSet mocks base method.
func (m *Mockoracle) ActiveSet(arg0 context.Context, arg1 types.EpochID) ([]types.ATXID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ActiveSet", arg0, arg1)
	ret0, _ := ret[0].([]types.ATXID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ActiveSet indicates an expected call of ActiveSet.
func (mr *MockoracleMockRecorder) ActiveSet(arg0, arg1 any) *MockoracleActiveSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActiveSet", reflect.TypeOf((*Mockoracle)(nil).ActiveSet), arg0, arg1)
	return &MockoracleActiveSetCall{Call: call}
}

// MockoracleActiveSetCall wrap *gomock.Call
type MockoracleActiveSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockoracleActiveSetCall) Return(arg0 []types.ATXID, arg1 error) *MockoracleActiveSetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockoracleActiveSetCall) Do(f func(context.Context, types.EpochID) ([]types.ATXID, error)) *MockoracleActiveSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockoracleActiveSetCall) DoAndReturn(f func(context.Context, types.EpochID) ([]types.ATXID, error)) *MockoracleActiveSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
