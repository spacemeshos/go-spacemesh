// Code generated by fastssz. DO NOT EDIT.
package tortoisebeacon

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/spacemeshos/go-spacemesh/common/types"
)

// MarshalSSZ ssz marshals the ProposalMessage object
func (p *ProposalMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposalMessage object to a target array
func (p *ProposalMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'EpochID'
	dst = ssz.MarshalUint32(dst, uint32(p.EpochID))

	// Offset (1) 'MinerPK'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.MinerPK)

	// Offset (2) 'VRFSignature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.VRFSignature)

	// Field (1) 'MinerPK'
	if len(p.MinerPK) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.MinerPK...)

	// Field (2) 'VRFSignature'
	if len(p.VRFSignature) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.VRFSignature...)

	return
}

// UnmarshalSSZ ssz unmarshals the ProposalMessage object
func (p *ProposalMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2 uint64

	// Field (0) 'EpochID'
	p.EpochID = types.EpochID(ssz.UnmarshallUint32(buf[0:4]))

	// Offset (1) 'MinerPK'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size {
		return ssz.ErrOffset
	}

	// Offset (2) 'VRFSignature'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (1) 'MinerPK'
	{
		buf = tail[o1:o2]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(p.MinerPK) == 0 {
			p.MinerPK = make([]byte, 0, len(buf))
		}
		p.MinerPK = append(p.MinerPK, buf...)
	}

	// Field (2) 'VRFSignature'
	{
		buf = tail[o2:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(p.VRFSignature) == 0 {
			p.VRFSignature = make([]byte, 0, len(buf))
		}
		p.VRFSignature = append(p.VRFSignature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposalMessage object
func (p *ProposalMessage) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'MinerPK'
	size += len(p.MinerPK)

	// Field (2) 'VRFSignature'
	size += len(p.VRFSignature)

	return
}

// MarshalSSZ ssz marshals the FirstVotingMessageBody object
func (f *FirstVotingMessageBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FirstVotingMessageBody object to a target array
func (f *FirstVotingMessageBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'ValidProposals'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(f.ValidProposals); ii++ {
		offset += 4
		offset += len(f.ValidProposals[ii])
	}

	// Offset (1) 'PotentiallyValidProposals'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(f.PotentiallyValidProposals); ii++ {
		offset += 4
		offset += len(f.PotentiallyValidProposals[ii])
	}

	// Field (0) 'ValidProposals'
	if len(f.ValidProposals) > 4096 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(f.ValidProposals)
		for ii := 0; ii < len(f.ValidProposals); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(f.ValidProposals[ii])
		}
	}
	for ii := 0; ii < len(f.ValidProposals); ii++ {
		if len(f.ValidProposals[ii]) > 4096 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, f.ValidProposals[ii]...)
	}

	// Field (1) 'PotentiallyValidProposals'
	if len(f.PotentiallyValidProposals) > 4096 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(f.PotentiallyValidProposals)
		for ii := 0; ii < len(f.PotentiallyValidProposals); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(f.PotentiallyValidProposals[ii])
		}
	}
	for ii := 0; ii < len(f.PotentiallyValidProposals); ii++ {
		if len(f.PotentiallyValidProposals[ii]) > 4096 {
			err = ssz.ErrBytesLength
			return
		}
		dst = append(dst, f.PotentiallyValidProposals[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the FirstVotingMessageBody object
func (f *FirstVotingMessageBody) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'ValidProposals'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'PotentiallyValidProposals'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'ValidProposals'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		f.ValidProposals = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 4096 {
				return ssz.ErrBytesLength
			}
			if cap(f.ValidProposals[indx]) == 0 {
				f.ValidProposals[indx] = make([]byte, 0, len(buf))
			}
			f.ValidProposals[indx] = append(f.ValidProposals[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'PotentiallyValidProposals'
	{
		buf = tail[o1:]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		f.PotentiallyValidProposals = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 4096 {
				return ssz.ErrBytesLength
			}
			if cap(f.PotentiallyValidProposals[indx]) == 0 {
				f.PotentiallyValidProposals[indx] = make([]byte, 0, len(buf))
			}
			f.PotentiallyValidProposals[indx] = append(f.PotentiallyValidProposals[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FirstVotingMessageBody object
func (f *FirstVotingMessageBody) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'ValidProposals'
	for ii := 0; ii < len(f.ValidProposals); ii++ {
		size += 4
		size += len(f.ValidProposals[ii])
	}

	// Field (1) 'PotentiallyValidProposals'
	for ii := 0; ii < len(f.PotentiallyValidProposals); ii++ {
		size += 4
		size += len(f.PotentiallyValidProposals[ii])
	}

	return
}

// MarshalSSZ ssz marshals the FirstVotingMessage object
func (f *FirstVotingMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FirstVotingMessage object to a target array
func (f *FirstVotingMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'FirstVotingMessageBody'
	dst = ssz.WriteOffset(dst, offset)
	offset += f.FirstVotingMessageBody.SizeSSZ()

	// Offset (1) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.Signature)

	// Field (0) 'FirstVotingMessageBody'
	if dst, err = f.FirstVotingMessageBody.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	if len(f.Signature) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, f.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the FirstVotingMessage object
func (f *FirstVotingMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'FirstVotingMessageBody'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'Signature'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'FirstVotingMessageBody'
	{
		buf = tail[o0:o1]
		if err = f.FirstVotingMessageBody.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Signature'
	{
		buf = tail[o1:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(f.Signature) == 0 {
			f.Signature = make([]byte, 0, len(buf))
		}
		f.Signature = append(f.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FirstVotingMessage object
func (f *FirstVotingMessage) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'FirstVotingMessageBody'
	size += f.FirstVotingMessageBody.SizeSSZ()

	// Field (1) 'Signature'
	size += len(f.Signature)

	return
}

// MarshalSSZ ssz marshals the FollowingVotingMessageBody object
func (f *FollowingVotingMessageBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FollowingVotingMessageBody object to a target array
func (f *FollowingVotingMessageBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Offset (0) 'MinerID'
	dst = ssz.WriteOffset(dst, offset)
	offset += f.MinerID.SizeSSZ()

	// Field (1) 'RoundID'
	dst = ssz.MarshalUint32(dst, uint32(f.RoundID))

	// Offset (2) 'VotesBitVector'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.VotesBitVector) * 8

	// Field (0) 'MinerID'
	if dst, err = f.MinerID.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'VotesBitVector'
	if len(f.VotesBitVector) > 4096 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(f.VotesBitVector); ii++ {
		dst = ssz.MarshalUint64(dst, f.VotesBitVector[ii])
	}

	return
}

// UnmarshalSSZ ssz unmarshals the FollowingVotingMessageBody object
func (f *FollowingVotingMessageBody) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2 uint64

	// Offset (0) 'MinerID'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Field (1) 'RoundID'
	f.RoundID = types.RoundID(ssz.UnmarshallUint32(buf[4:8]))

	// Offset (2) 'VotesBitVector'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Field (0) 'MinerID'
	{
		buf = tail[o0:o2]
		if err = f.MinerID.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'VotesBitVector'
	{
		buf = tail[o2:]
		num, err := ssz.DivideInt2(len(buf), 8, 4096)
		if err != nil {
			return err
		}
		f.VotesBitVector = ssz.ExtendUint64(f.VotesBitVector, num)
		for ii := 0; ii < num; ii++ {
			f.VotesBitVector[ii] = ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FollowingVotingMessageBody object
func (f *FollowingVotingMessageBody) SizeSSZ() (size int) {
	size = 12

	// Field (0) 'MinerID'
	size += f.MinerID.SizeSSZ()

	// Field (2) 'VotesBitVector'
	size += len(f.VotesBitVector) * 8

	return
}

// MarshalSSZ ssz marshals the vrfMessage object
func (v *vrfMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the vrfMessage object to a target array
func (v *vrfMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Prefix'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Prefix)

	// Field (1) 'Epoch'
	dst = ssz.MarshalUint32(dst, v.Epoch)

	// Field (0) 'Prefix'
	if len(v.Prefix) > 64 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, []byte(v.Prefix)...)

	return
}

// UnmarshalSSZ ssz unmarshals the vrfMessage object
func (v *vrfMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Prefix'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Field (1) 'Epoch'
	v.Epoch = ssz.UnmarshallUint32(buf[4:8])

	// Field (0) 'Prefix'
	{
		buf = tail[o0:]
		if len(buf) > 64 {
			return ssz.ErrBytesLength
		}
		v.Prefix = string(buf)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the vrfMessage object
func (v *vrfMessage) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Prefix'
	size += len(v.Prefix)

	return
}
